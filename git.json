[{"text":"1.\n\n\nWHAT IS GIT AND WHY IS IT USED?","answer":"Git is a decentralized version control system (DVCS) that developers primarily\nuse to manage source code across diverse development projects. It ensures better\ncode quality, facilitates teamwork, and provides a robust backup mechanism.\n\n\nBENEFITS OF USING GIT\n\n * History and Time Travel: Git preserves every version of a project, making it\n   possible to roll back changes or inspect code at any point.\n\n * Security and Integrity: Each file in Git has a unique SHA-1 hash, which means\n   unauthorized changes are easily detected.\n\n * Collaboration: Git allows multiple developers to work on a project\n   simultaneously without conflict.\n\n * Code Reviews: Git simplifies the process of reviewing code before it's\n   incorporated into the main codebase.\n\n\nKEY CONCEPTS\n\nCOMMIT\n\nA commit represents a saved state of your project. It is a snapshot of all the\nfiles in your project at a given point in time. Each commit has a commit message\nassociated with it.\n\nBRANCH\n\nA branch is an independent line of development. It allows you to work on a\nfeature or bug fix, isolate it from the rest of the codebase until it is ready,\nand then merge it back in.\n\nMaster is a default branch present in all Git repositories. You can create many\nother branches.\n\nMERGE\n\nMerging in Git means taking the independent developments of two branches and\ncombining them into a single branch.\n\nAfter merging, the two branches from which you were merging are the same as the\nmerged branch.\n\nREMOTE AND ORIGIN\n\nA remote is a common repository on a server or accessible memory that all team\nmembers use to exchange their changes.\n\nAn origin is a source of commit objects (store of all committed versions).\n\n\nTHE COMMAND LINE VS VISUAL TOOLS\n\nFor everyday tasks, both CLI and GUI are powerful, but it's essential to\nunderstand Git's underlying mechanics so that you can troubleshoot and manage\ncomplex tasks efficiently.\n\n\nBEGINNER TIPS\n\n * Make frequent commits.\n * Write clear and concise commit messages.\n * Push your code to a remote repository often, especially before taking a break\n   or finishing a task.","index":0,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"2.\n\n\nHOW DOES GIT DIFFER FROM OTHER VERSION CONTROL SYSTEMS (VCS)?","answer":"Git offers numerous advantages over traditional Version Control Systems (VCS),\nproviding a distributed and efficient version control model.\n\n\nUNIQUE FEATURES\n\n * Distributed Model: Git decentralized nature empowers every set of files with\n   a complete repository history and enables full-fledged operations without\n   network connectivity. This stands in contrast to centralized systems that\n   require a constant network connection and utilize a single centralized server\n   for all project data.\n\n * Quick Operations: Git is renowned for its fast and efficient operations.\n   Unlike older VCS, which often performed slowly or required substantial server\n   interactions, Git uses local operations, resulting in impressive speed.\n\n * Data Integrity: Git ensures the cryptographic integrity of every piece of\n   data, securing against file corruption, loss, or unauthorized alterations.\n   The absence of this feature in some traditional VCS can pose data integrity\n   risks.\n\n * Streamlined Branching: While segments or branches in older VCS were often\n   used for parallel development, Git branches are lightweight and designed for\n   quick and frequent usage.\n\n * Customizable Workflows: Git permits versatile workflows due to its\n   distributed nature and the ability to manipulate the commit history before\n   sharing changes with others.\n\n * Staging Area (Index): Before committing, developers use the \"staging area\" to\n   selectively include specific changes in a commit rather than committing every\n   altered file.\n\n * Powerful Library of Core Commands: Git's robust set of indispensable commands\n   enables a broad range of version control capabilities, from historical\n   revision exploration to collaborative feature code management.\n\n\nCONSIDER THE USER\n\n * Simplicity and Flexibility: Unlike some traditional VCS, Git is designed to\n   be both user-friendly and capable of supporting complex tasks.\n\n * Efficiency and Performance: Git's rapid and streamlined processes lead to\n   optimized efficiency.\n\n\nUNEXPECTED CHANGE? NO PROBLEM!\n\n * Snapshot vs File Tracking: Git's snapshots record the current state of the\n   complete repository, whereas some traditional VCS, such as CVS and\n   Subversion, primarily track file changes.\n\n * Atomic Commits: Every change is distinct and exclusive from others, enabling\n   precise control over data synchronization.\n\n\nGIT: NOW AND HEREAFTER\n\n * Modern Landscape Readiness: Git melodiously integrates with modern software\n   development paradigms like Continuous Integration/Continuous Deployment\n   (CI/CD).\n\n * Cross-Platform Compatibility: Be it Windows, macOS, or Linux, Git operates\n   identically.\n\nWHAT ARE SOME DRAWBACKS OF OTHER VCS?\n\n * Risk of Single Point of Failure: If the central server is compromised, it\n   poses a threat to the entire project's data.\n\n * Version Numbering Limitations: Users might be confined to a monotonically\n   increasing number for versions, restricting granularity.\n\n * Long-Term Integrity Risks: Without cryptographic validation, files can be\n   altered unnoticed.\n\n * Data Loss Complications: If a central server/repository is compromised or\n   damaged, data loss is severe.\n\n * Limited Offline Functionality: Users are hindered by the necessity of a\n   steady network connection.\n\n * Stale Branches: Centralized repositories can have stale branches, hindering\n   collaboration.","index":1,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"3.\n\n\nWHAT IS THE DIFFERENCE BETWEEN GIT AND GITHUB?","answer":"Git and GitHub are often confused due to their similar names. However, they\nserve different version control and development hosting purposes.\n\n\nGIT\n\nGit is a distributed version control system that manages code and tracks its\nchanges. It's mainly a local solution, only allowing developers to coordinate\ndirectly.\n\nKEY FEATURES\n\n * Local Management: Developers can work on their repositories without the need\n   for a central server.\n * Speed: Operations such as committing, branching, and merging are rapid, ideal\n   for local development.\n * Staging Area: Changes are first staged before getting committed for better\n   control.\n * Content Tracking: Rather than file-based, Git is content-based, ensuring\n   efficient tracking.\n\n\nGITHUB\n\nGitHub, on the other hand, is a web-based platform that provides hosting for Git\nrepositories. It offers features that extend beyond Git's core functionality.\n\nKEY FEATURES\n\n * Remote Repositories: It allows developers to sync their local repositories\n   with remote ones, enabling collaborative work.\n * Code Hosting: Developers can store and manage their code from anywhere, not\n   just their local machines.\n * Collaboration Tools: GitHub provides tools for project management, issue\n   tracking, and team collaboration.\n * Code Review: Multiple users can review and discuss proposed changes before\n   they're merged into the main codebase.\n * Access Control: Different users can have varying levels of access to a\n   repository or organization.","index":2,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"4.\n\n\nWHAT IS A REPOSITORY IN GIT?","answer":"A Git repository is a location where all the version-controlled files and their\nhistory are stored. It serves as the core component for collaborative and\nversion control workflows.\n\nEvery Git repository has two primary parts: the working tree and the hidden .git\ndirectory, where Git keeps all of its metadata for the repository.\n\n\nKEY FEATURES\n\n * Distributed: Each contributor to the project has their own copy of the\n   repository, including its complete history and version-tracking capability.\n   This enables offline work and serves as a backup for the project.\n\n * Efficient Storage: Git optimizes storage using techniques such as file\n   hashing and delta compression, emphasizing minimal redundancy and data\n   redundancy elimination.\n\n * Content Integrity: All files in a Git repository, as well as their versions,\n   are checksummed and verified on every Git operation for data integrity.\n\n * Work Tracking: Git allows for tracking changes made to the project over time,\n   helping individuals or teams understand the evolution of the project, who\n   made specific changes, and why.\n\n\n.GIT DIRECTORY\n\nThe .git directory is the control center of a Git repository, housing everything\nGit needs to manage the repository and its history. It includes:\n\n * The object database that hosts all the data about commits, trees, and blobs.\n * The references directory maintaining pointers to specific commits (e.g.,\n   branches and tags).\n * Configuration files detailing the repository's settings and attributes.\n\n\nWORKING TREE\n\nThe working tree is a directory where tracked files are extracted for viewing\nand editing. Any changes made to files in the working tree can be staged and\ncommitted to the repository to capture the changes.\n\nUntracked files, i.e., files not previously staged or committed, coexist with\nthe working tree and reside outside the Git management.\n\n\nCODE EXAMPLE: WORKING TREE\n\nHere is the Python code:\n\n# Let's define a variable to point to the .git directory\ngit_directory = '.git'\n\n# Now, we can simulate the construction of our working tree using a dictionary\nworking_tree = {\n    'folder1': {\n        'file1.py': 'print(\"Hello, World!\")'\n    },\n    'folder2': {\n        'file2.py': 'print(2 + 2)'\n    }\n}\n","index":3,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"5.\n\n\nEXPLAIN THE CONCEPT OF A COMMIT IN GIT.","answer":"In Git, a commit represents a snapshot of a project at a specific point in time.\nEach commit records the changes made, the author, and a unique identifier.\nIt is organized in a directed acyclic graph (DAG), which aligns with its\nbranching model.\n\n\nKEY ELEMENTS OF A GIT COMMIT\n\n * Tree: Represents the state of the project's file system at the time of the\n   commit. The tree object is a record of the location and content of each file\n   in the repository.\n * Parent Commit(s): Identifies the commit(s) from which the current commit\n   originated. In the case of the initial commit, there's no parent.\n * Metadata: Includes details such as the commit's author, date, and a message\n   summarizing the changes made.\n\n\nTHE THREE-TREE ARCHITECTURE\n\nIn a typical Git repository, there is a working directory, staging area, and\ncommit history. Each tracks the project's state at various stages.\n\n * Working Directory: Refers to the current, live set of files and directories.\n   This is the version of the project that you actively work on and modify.\n * Staging Area (also known as the \"index\"): Serves as a buffer zone. Files in\n   this area are marked for inclusion in the next commit. You control what\n   content moves from the working directory to the staging area.\n * Commit History (in the Git directory): Represents the timeline of commits in\n   the form of a versioned archive. It also houses the full content of the\n   project at relevant commit points.\n\n\nTHE GIT LIFECYCLE\n\nThe standard git-flow follows a lifecycle that incorporates the three trees\nmentioned above.\n\n * Creating Commits: You start by making changes to your working directory. When\n   you're ready to record these changes, you add specific files from the working\n   directory to the staging area. With the desired changes in the staging area,\n   the next command captures the staging area's content and creates a new commit\n   in the commit history.\n\n * Browsing History: Git's commit history is time-ordered, typically from the\n   most recent commit backward. Each commit influences how the project appears\n   at a given point in time.\n\n\nVIEWING COMMIT HISTORY\n\nYou can view the commit history using commands such as git log. This command\nprovides a structured list of commits, detailing the author, commit date, and an\nassociated commit message.\n\n\nPRACTICAL APPLICATIONS\n\n * Code Reversion: You can reset a project to an earlier commit, effectively\n   reversing changes.\n * Collaboration: Commits facilitate collaboration by enabling team members to\n   understand changes and when they were made.\n * Code Review: Before incorporating changes into the primary branch, commits\n   offer a structured way for team members to review each other's code. This\n   process ensures that new code meets the repository's standards.\n\n\nCODE EXAMPLE: COMMIT CREATION AND VIEWING\n\nHere is the Git console command to create \"Meaingful Commit\" with a message and\nthen to view the Commit.\n\n# To make a commit with a message\ngit commit -m \"Meaningful Commit\"\n\n# To view the commit history\ngit log\n","index":4,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"6.\n\n\nWHAT IS THE DIFFERENCE BETWEEN A WORKING DIRECTORY, STAGING AREA, AND REPOSITORY\nIN GIT?","answer":"Git is characterized by a three-tiered architecture which includes the following\nlayers:\n\n * Working Directory\n * Staging Area\n * Repository\n\nEach layer plays a distinct role in the Git architecture.\n\n\nCORE CONCEPTS\n\nWORKING DIRECTORY\n\nThe working directory is your playground. It's your space for experimenting,\nwhere you can edit files, merge different versions, and even create new ones.\n\nSTAGING AREA (INDEX)\n\nThe staging area (also known as the Index) is a kind of middle-ground. Here you\ncan make fine adjustments to what changes will be included in your next commit.\nYou have two types of files here:\n\n * MDS: Files that have been modified since your last commit\n * SML: Files that have been changed and prepared for your next commit\n\nWhen you're happy with your changes in the staging area, you \"stage\" them.\nStaging in this context is like flagging certain parts of your project that you\nwant to be saved in your next commit. Notice that this step is completely\noptional.\n\nREPOSITORY (HISTORY)\n\nThe repository is the final tier, dealing with the preservation of your work.\nThink of it as the local repository that serves as the safe house for all your\ncommits. It keeps track of all changes and commits you've made, ensuring that\nyou can still retrieve them even after major updates.\n\nThe repository is also broken down into three apparent \"trees\" - the Working\nDirectory, the Staging Area, and the last one, the HEAD. The HEAD points to your\nmost recent commit. These three trees can seem confusing at first. But really,\nthey're straightforward to understand - they represent the current status of\nyour project, changes that you're planning to commit, and the commits that\nyou've confirmed you want to save in the future.","index":5,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"7.\n\n\nDEFINE BRANCHING IN GIT AND ITS IMPORTANCE.","answer":"Branching in Git allows for the independent development of distinct features or\nsections of the codebase. It's a crucial version control strategy, particularly\nin collaborative projects.\n\n\nKEY CONCEPTS\n\n * Master/Trunk/Branch: The primary branch serving as the project source.\n\n * Feature Branches: Additional branches dedicated to specific features or\n   tasks, often derived from the Master branch.\n\n * Merging: The process of integrating changes from one branch into another. For\n   instance, integrating finished feature branches into the Master.\n\n * Conflict Resolution: The act of resolving overlapping changes made to the\n   codebase across different branches.\n\n\nTHE IMPORTANCE OF BRANCHING\n\n 1. Code Isolation: Each feature branch is an isolated environment for\n    developing a specific feature. This avoids interference with the main\n    codebase.\n\n 2. Collaborative Development: Allows multiple developers to work on the same\n    codebase concurrently, minimizing conflicts.\n\n 3. Risk Mitigation: Changes are kept separate until they are thoroughly tested.\n    If an experimental feature doesn't work as expected or introduces bugs, it\n    won't affect the more stable Master branch.\n\n 4. Staging Area: A dedicated space for integration and testing before code is\n    deployed or merged into the Master branch.\n\n 5. Feature Toggles: Streamlines the process of selectively deploying new\n    features for testing.\n\n 6. Code Reviews: Assists in code quality checks before merging, ensuring the\n    Master branch remains stable.\n\n 7. Task Management: Aligns with project management tools and methodologies,\n    providing a way to structure tasks in a version-controllable manner.\n\n 8. Release Management: Facilitates the isolation and verification of changes\n    earmarked for specific releases.","index":6,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"8.\n\n\nWHAT IS A HEAD IN GIT?","answer":"In Git, the concept of a working directory, the staging area (or index), and the\nrepository (or commit history) are all managed by the HEAD.\n\n\nROLE OF HEAD IN GIT\n\n * Point of Reference: HEAD identifies the current snapshot/commit in the\n   history tree. Any actions in the working directory or staging area are based\n   on this commit.\n\n * Connector between Levels: It links the most recent commit in a branch to both\n   the staging area and the working directory. Each commit is precisely what\n   HEAD points to.\n\n\nCODE EXAMPLE: WORKING WITH HEAD\n\nHere is the visual representation of How Git Works.\n\nHere is the python code:\n\n# Check out the \"first-branch\" branch\ngit checkout first-branch\n\n# Make some modifications and stage them\ngit add modified-file-1.txt\n\n# Commit the staged changes\ngit commit -m \"Modified file 1 in first branch\"\n\n# Verify the new `HEAD` after the commit\ngit log --oneline --decorate\n\n\nThe git log command in the above code includes the --decorate option, displaying\nthe most recent commit and any associated references.","index":7,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"9.\n\n\nWHAT DOES THE 'CLONE' OPERATION IN GIT DO?","answer":"Cloning in Git creates a local copy of the repository, allowing for version\ncontrol and collaborative work. It establishes a link to a specified remote,\npermitting fetch and push operations.\n\n\nKEY ATTRIBUTES\n\n * Two-Part Process: Cloning involves duplicating the repository and setting up\n   the local environment.\n * Full Version History: The cloned repository typically includes all commits\n   and file versions.\n * Remote Linkage: A relationship is built with a designated remote for data\n   synchronization.\n\n\nTERMINOLOGY OVERVIEW\n\n * Local Repository: Storage on the user's machine where all project and version\n   data reside.\n * Remote Repository: An external, shared storage often on a server, accessible\n   for collaborative work.\n * Working Directory: The location on the user's file system where files are\n   manipulated and changes are tracked for commits.\n\n\nCORE FUNCTIONALITY\n\n * Duplication: The clone process reproduces the entire project, with all\n   branches and commits, onto the user's machine. This offers a complete,\n   standalone history.\n * Configuration: The local environment is configured to maintain\n   synchronization with a specific remote repository. By default, the repository\n   from which the clone is made (origin) is set as the primary remote, but\n   additional remotes can be added if required.\n * Integrity: Git ensures the integrity of the copied data, such as commits and\n   file snapshots, during the cloning process.\n * Selective History Contraints: While it's common for a clone to receive the\n   entire repository history, limited cloning is also possible, especially with\n   large repositories. Technique like shallow cloning or specifying a certain\n   commit for cloning can be used.\n\n\nFORMING THE CONNECTION\n\nAfter a successful clone, the local repository is configured to interact with a\ndesignated remote repository, typically on a centralized server like Github or\nBitbucket.\n\nFor GitHub, cloning often uses the HTTPS mode. Upon updates to the remote, the\nlocal repository can be synchronized using standard Git commands (e.g., fetch,\npull, push).\n\nTechnically, clonality is not tied to a specific remote URL; it's more about\naligning the histories. For instance, after cloning from GitHub using HTTPS,\nremotes can be reconfigured to use SSH.\n\n\nDETAILED PROCESS\n\n 1. Acquiring Data: The clone command contacts the remote repository, retrieves\n    its history and files, and then saves this snapshot locally.\n\n 2. Repository Creation: The git clone execution sets up a new repository,\n    employing the data fetched from the target remote, and thus creates both the\n    working directory and associated .git directory, which hosts the entire Git\n    control structure.\n\n 3. Linkage Configuration: The clone operation automatically establishes a\n    remote connection, naming it \"origin\" by default. Should you have multiple\n    remotes or wish to use a different name, configuration adjustments may be\n    required.\n\n 4. Extraction: The clone accomplishes the creation and association of the local\n    repository, which users can then \"extract\" to their working directories for\n    manipulation.\n\n 5. Status Verification: Confirming the successful execution of a clone can be\n    done by taking a look at the current remotes via git remote -v, which should\n    display the origin.\n\n\nTECHNICAL COMMANDS\n\n * Clone: Initiate the cloning process.\n   \n   git clone <remote-repo-url>\n   \n\n * Remote: Verify origin setup.\n   \n   git remote -v\n   ","index":8,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"10.\n\n\nHOW DOES GIT STORE INFORMATION?","answer":"While Git does use a filesystem to store data, it isn't exclusively file-based.\nThe three main components of the Git data structure are the repository, the\nindex/staging area, and the local working copy.\n\n\nGIT STORAGE MODEL\n\n 1. Local Working Copy: Where you directly interact with your files.\n 2. Staging Area (Index): Serves as a sort of \"holding area\" for changes you\n    want to include in your next commit.\n 3. Local Repository: Where Git keeps track of the complete history and stores\n    different versions of your files.\n\n\nREPOSITORY\n\nThe repository houses the following key components:\n\n * Object Database: Persistently stores snapshots of files and directories as\n   objects, which can be further classified into:\n   \n   * Blob objects for individual file contents.\n   * Tree objects that replicate file system hierarchy.\n   * Commit objects linked to a specific state in the project's history.\n   * Tag objects marking specific commits, often used for releases.\n\n * Index/Stage: A dynamic workspace that mirrors the next commit's expected\n   state.\n\n * Head Pointer: A reference to the latest commit in your current working branch\n\n * Branches: Human-readable names that reference specific commits, facilitating\n   independent lines of development.\n\n\nGIT OBJECT NAMES\n\n 1. Blobs: SHA-1 hash is based on the file's content.\n 2. Trees: SHA-1 hash combines the file and directory contents within—changes in\n    any file or sub-directory would trigger a new hash.\n 3. Commits: SHA-1 hash incorporates the tree representing the project's\n    directory structure, along with parent commit(s), commit message, and author\n    information.\n\n\nGIT OBJECT STORAGE\n\nGit allows for a 'lazy write' mechanism for objects. This means that an object\nfile is written upon creation and remains unchanged until the content it\nrepresents changes. When a change occurs, it gets updated and its SHA-1 is\nrecalculated. This particular feature is known as 'immutable storage'.\n\nHere's an illustration for better understanding:\n\n * Let's assume a file's content changes and you add the updated file to the\n   staging area.\n * The new version of the file is then stored as a Blob object, and the\n   associated Tree object also gets updated.\n * During the following commit, a new Commit object is created, which references\n   the updated Tree object.\n * Simultaneously, the Branch you're working on moves forward to reference this\n   new commit.\n\nThis systematic approach assures the integrity of your project's history. Since\nany alteration in content, directory structure, or commit details will trigger a\nchange in the SHA-1 hash of the related object(s), a change can be immediately\nrecognized.","index":9,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"11.\n\n\nHOW DO YOU INITIALIZE A NEW GIT REPOSITORY?","answer":"Let's go through the step-by-step process of creating a new Git repository and\nthen getting started by adding files, making commits, and pushing the repository\nto a remote location such as GitHub or Bitbucket.\n\n\nINITIALIZING A NEW GIT REPOSITORY\n\nUSING THE COMMAND LINE\n\n 1. Navigate to your project folder using your terminal or command prompt.\n 2. Run the following command to initialize a new Git repository:\n\ngit init\n\n\nUSING GIT GUI\n\nMost Git GUI applications, like Sourcetree or GitKraken, facilitate setting up\nrepositories through an intuitive interface. Once you've navigated to your\nproject folder, choose the \"Initialize/Create New Repository\" option.\n\n\nGETTING STARTED: ADDING FILES, MAKING COMMITS, AND PUSHING TO REMOTE\n\nADDING FILES TO THE STAGING AREA\n\nUse the following command to add files or directories to the staging area:\n\n# To add a specific file\ngit add filename\n\n# To add all files and directories\ngit add .\n\n\nCOMMITTING CHANGES\n\nOnce files are in the staging area, use this command to commit these changes:\n\ngit commit -m \"Your commit message goes here\"\n\n\nASSOCIATING A REMOTE REPOSITORY\n\nIf you plan to push your local repository to an online service like GitHub,\nfirst link your local repository to a remote one:\n\ngit remote add origin your-remote-repository-url\n\n\nReplace \"your-remote-repository-url\" with the URL provided by your online\nrepository.\n\nPUSHING TO REMOTE\n\nFinally, use this command to push your local repository to the remote one:\n\ngit push -u origin master\n\n\nAfter the initial \"upstream\" link is established, subsequent push commands can\nbe executed with a simple git push.\n\n\nHANDLING SENSITIVE INFORMATION\n\nTo ensure that sensitive data, such as API keys or credentials, are not shared,\nemploy the .gitignore file to list files and patterns that should be excluded\nfrom version control.\n\nIn particular, avoid using files with such sensitive information before creating\na .gitignore.\n\nHere is the .gitignore file:\n\n# Ignored file - example\ncredentials.txt\n","index":10,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"12.\n\n\nEXPLAIN THE PURPOSE OF THE GIT STATUS COMMAND.","answer":"git status is an essential command for tracking changes in a Git repository. It\nprovides important details such as file states, current working branch,\nuntracked files, and more.\n\n\nKEY OUTPUT INFORMATION\n\n * On Branch: Indicates the active branch, allowing quick navigation through\n   different branches.\n\n * Changes to be Committed: Lists modified or staged files, providing a quick\n   glance at what will be included in the next commit.\n\n * Changes not staged for commit: Highlights modified files that were not yet\n   staged for the next commit.\n\n * Untracked Files: Recognizes files in the working directory that are not a\n   part of the repository.\n\n * Branch is Up to Date: Provides this affirmation when the working branch is\n   up-to-date with its remote counterpart.\n\n * Your Branch is Ahead of 'origin/master' by 1 Commit: Notifies when the\n   current local branch outpaces the linked remote branch by a set number of\n   commits. This is common in team-based workflows and signifies the necessity\n   of a push.\n   \n   Note: The remote branch in the example is 'origin/master', and the number of\n   commits ahead is 1.\n\n\nCODE EXAMPLE: TERMINAL OUTPUT OF GIT STATUS\n\nHere is the code:\n\nOn branch main\nYour branch is up to date with 'origin/main'.\n\nChanges to be committed:\n     (use \"git restore --staged <file>...\" to unstage)\n    modified:   app.js\n\nUntracked files:\n     (use \"git add <file>...\" to include in what will be committed)\n    server.js\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n\n\n\nCODE EXAMPLE: VISUAL DIFF OF STAGED CHANGES USING GIT DIFF --STAGED\n\nHere is the code:\n\ndiff --git a/readme.txt b/readme.txt\nindex ce01362..0602794 100644\n--- a/readme.txt\n+++ b/readme.txt\n@@ -1 +1 @@\n- Initial file version\n+ Modified during stage\n\n\n\nCODE EXAMPLE: MULTIFILE GIT STATUS OUTPUT\n\nHere is the code:\n\nOn branch: master\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n      modified:   file1.cpp\n      modified:   file2.cpp\nBoth file3.cpp and file4.cpp are untracked.\nYour branch and 'origin/master' have diverged,\nand have 4 and 2 different commits each, respectively.\n\n\n\nBEST PRACTICES\n\n * Regularly use git status to stay updated on the repository's state.\n * Review and comprehend the provided information before proceeding with any\n   actions, such as staging or committing.","index":11,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"13.\n\n\nWHAT DOES THE GIT ADD COMMAND DO?","answer":"git add is the first step in tracking changes you make to existing files or\nadding new files to your Git repository. It prepares the changes for the next\ncommit by moving modified or new files to the staging area.\n\nWhen you invoke git add, three major actions take place:\n\n 1. File Selection: You choose which specific file changes to include in the\n    upcoming commit.\n\n 2. File Comparison: Git analyzes the selected files and identifies the exact\n    line-by-line or block-level modifications.\n\n 3. Staging Area Update: The selected file changes are prepared and categorized.\n    Once you're ready, you can make a commit action to move all the changes in\n    the staging area to the repository.\n\n\nRELATION MANAGER\n\nThe staging area acts as a bridge between your working directory and the\nrepository (history).\n\n * Working Directory: Contains the active files you're currently editing.\n\n * Staging Area (Index): A kind of \"Sandbox\" where you selectively group changes\n   together for precise commits.\n\n * Repository: The historical record of all your commits and their respective\n   states.\n\n\nKEY ACTIONS\n\n * Add All Modifications: Restage modified files to the current state: git add .\n\n * Add Interactively: Handpick changes from modified files: git add -p\n\n * Merge Conflicts: After addressing conflicts, ready files for commit: git add\n   <filename>\n\n\nCODE EXAMPLE: STAGING VS GIT HISTORY\n\nHere is the Python code:\n\n# File: my_file.py  (in the working directory)\n\n# Current content\nprint(\"This line is part of the initial version.\")\n\n# Post staging changes (not committed yet)\nprint(\"This line will be part of the next commit.\")\n\n\nIn our Python example, consider \"file.py\" as the file. Initially, the file\ncontains one line, which was the initial version. Then \"This line will be part\nof the next commit.\" gets added (not committed yet), so that these changes occur\nbetween git add and git commit.","index":12,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"14.\n\n\nHOW DO YOU CREATE A COMMIT IN GIT?","answer":"Let's look at the process of creating a commit in Git:\n\n\n1. IDENTIFYING TRACKED AND UNTRACKED FILES\n\nBefore making a commit, the user should review any changes in the working\ndirectory and staging area.\n\nUntracked Files: These are new files that Git does not track yet. To track\nuntracked files and subsequently include them in a commit, they need to be\nstaged using the git add command.\n\nTracked Files: Files that have previously been committed or added to the staging\narea can be included in the next commit.\n\n\n2. WAYS TO SELECT FILES FOR COMMIT\n\nGIT ADD OPTIONS\n\n * Specific Files: Directly add individual files or a group of files using their\n   names or paths.\n   \n   git add file1.txt path/to/file2.txt\n   \n\n * By Pattern: Use wildcards or named sets of files to add multiple files at\n   once.\n   \n   git add *.txt\n   \n\n * Interactively: Launch a prompt where changes can be reviewed and selected for\n   staging.\n   \n   git add -i\n   \n\nGIT RM AND GIT MV\n\nThese commands remove and rename files respectively. Changes are then staged and\ncommitted similarly to new additions.\n\nGIT RESET\n\nUnstage files that were mistakenly added to the staging area.\n\ngit reset file1.txt\n\n\nGIT CHECKOUT\n\nTo remove changes in the working directory, bring them back to the state of the\nHEAD commit.\n\ngit checkout file1.txt\n\n\nGIT COMMIT\n\nThis command is used to save changes to the local repository after they have\nbeen staged.\n\nParameters (optional):\n\n-M\n\nUse a one-line message to describe the commit.\n\ngit commit -m \"Add new feature xyz\"\n\n\n-A\n\nStage all modified files and commit them.\n\nThis command omits the staging step, effectively combining git add and git\ncommit. Since it bypasses the staging area completely, care should be taken when\nusing it, to ensure only intended changes are included in the commit.\n\ngit commit -am \"Update feature xyz\"\n\n\nWhen using -a without -m, Git will open the default text editor for you to\ncompose the commit message in a separate file.\n\n\n4. EXCLUDING FILES FROM A COMMIT\n\nSome files might not need to be committed, for example:\n\n * Temporary Files: This might include build artifacts or editor-specific\n   temporary files.\n * Sensitive Information: Such as passwords or private keys.\n\nFor such exclusions, you can define the file patterns or names in a .gitignore\nfile.\n\nTo exclude files globally, create or edit the global .gitignore file.\n\ngit config --global core.excludesfile ~/.gitignore_global\n\n\nThen, ensure to add a .gitignore file in the root directory for the local\nrepository if needed.\n\ntouch .gitignore\n\n\n\nCAUTION:\n\n * Avoid tracking, staging, or committing sensitive information.\n * Keep .gitignore up to date, especially in collaborative projects.","index":13,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"15.\n\n\nWHAT INFORMATION IS CONTAINED IN A COMMIT OBJECT IN GIT?","answer":"The commit object in Git encapsulates rich textual data that aids in tracking\nand managing changes in the repository.\n\n\nCORE ELEMENTS IN A COMMIT OBJECT\n\n * Author and Committer: These metadata entries contain the individual's name\n   and email address as well as the timestamp.\n * Commit Messages: They provide a brief yet comprehensive understanding of the\n   changes introduced in the commit, helping in maintaining clarity and context.\n * Parent Commits: This represents a pointer to one or more parent commits. In\n   the case of a merge commit, there can be more than one parent.\n   * The HEAD of most branches points to the most recent commit, and this\n     reference is what progresses as newer commits occur. The HEAD itself points\n     to the most recent commit but operates indirectly through the branch\n     reference.\n\n\nOTHER CORE CONTENTS\n\n * Tree Object: Each commit is linked to a tree object that represents the state\n   of the content in the repository at the time of the commit. The tree object,\n   in turn, holds references to the various blobs and subtrees.\n   * Here is a quick summary. A blob in Git is a file, and a tree is a\n     collection of files and can even include other trees.\n   * A commit, therefore, is created with a tree-referencing object, capturing\n     both the checked-in version of files (through the tree object) and a\n     metadata snapshot (through its unique SHA key).\n   * Internal to that tree are also the various subtrees and blobs that the tree\n     sticks to.\n\n\nDANGLING COMMITS\n\nIn cases when a branch or reference no longer points to a commit, Git still\nretains these dangling commits. Using git reflog, you can potentially recover\nthem.\n\n\nVERIFICATION WITH GPG\n\nAdvanced Git workflows often call for data integrity and authenticity,\nespecially in distributed teams and open-source projects. Git employs GitPG to\nsign commits, verifying the commit objects' authenticity, flagging potential\ntampering or forging of prior commits.","index":14,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"16.\n\n\nHOW DOES GIT PUSH DIFFER FROM GIT FETCH?","answer":"Both git push and git fetch are essential commands for collaborating in Git.\n\n\nKEY DISTINCTIONS\n\n * git push: Publishes local changes to the remote repository.\n * git fetch: Downloads remote changes to the local machine, updating the\n   remote-tracking branches like origin/master.\n\n\nCODE EXAMPLE: GIT FETCH\n\nHere is the shell command:\n\ngit fetch origin\ngit merge origin/master\n\n\nOne combined command is:\n\ngit pull origin master\n","index":15,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"17.\n\n\nEXPLAIN THE PURPOSE OF THE GIT PULL COMMAND.","answer":"git pull combines fetching from a remote repository and then merging with your\nlocal to keep both in sync.\n\nIt's most beneficial in collaborative environments or multitasking scenarios.\n\n\nFETCH VS. PULL\n\n * Fetch: Retrieves changes from a remote but doesn't integrate them with your\n   local files. Useful for inspecting changes before incorporating.\n * Pull: Fetches remote changes and automatically merges them into your current\n   branch.\n\n\nPULL AND FAST-FORWARD MERGES\n\ngit pull uses fast-forward merges whenever possible. This means that if your\nlocal branch development hasn't diverged from the remote branch (main, for\ninstance), git pull will bring the latest commits from main and integrate them\nlinearly.\n\n\nUSAGE CONSIDERATIONS\n\n * Selective Fetch: Fetching allows you to scrutinize the fetched changes before\n   merging. Use Fetch in workflows where you want more control.\n * Convenience in Collaboration: Simplifies syncing shared branches in teamwork\n   settings.\n\n\nCOMMON USAGE\n\nRunning git pull <remote> <branch> is equivalent to the sequence:\n\n 1. git fetch <remote> <branch>\n 2. git merge FETCH_HEAD\n\n\nCODE EXAMPLE: USING GIT PULL\n\nHere is the Git bash command:\n\ngit pull origin main\n","index":16,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"18.\n\n\nDESCRIBE THE USE OF GIT BRANCH COMMAND.","answer":"git branch serves two main functions: viewing existing branches and creating new\nones.\n\n\nVIEWING BRANCHES\n\n * To see both remote and local branches, use:\n   \n   git branch -a\n   \n\n * For a more detailed view, including the last commit on each branch, employ:\n   \n   git branch -v\n   \n\n * To visualize branch history through a branched graph, use:\n   \n   git log --all --decorate --oneline --graph\n   \n\n * To inspect the difference between two branches, use:\n   \n   git diff branch1..branch2\n   \n\n\nCREATING AND MANAGING BRANCHES\n\n * To create a new branch based on the current one, use:\n   \n   git branch new-branch\n   \n   \n   Or, if you want to switch to the new branch immediately, use:\n   \n   git checkout -b new-branch\n   \n\n * To delete a branch, use:\n   \n   git branch -d branch-to-delete\n   \n   \n   Replace -d with -D to force delete a branch that has not been merged.\n\n * To rename a branch, use:\n   \n   git branch -m new-name\n   \n   \n   Replace new-name with the desired branch name.\n\n * If you are working in a team and have local and remote branches, there are\n   different conventions for dealing with remote branches:\n   \n   * When you want to delete your local branch and the corresponding remote\n     branch, use:\n     \n     git push origin --delete branchname\n     git branch -d branchname\n     \n   \n   * If you want to keep your local branch after deleting the remote branch or\n     want to delete the remote branch later, use:\n     \n     git push origin --delete branchname\n     \n\n * To set the upstream branch for a local branch, use:\n   \n   git push -u origin branch-name\n   \n   \n   After doing this, your local branch will know which remote branch to push to\n   or pull from when using git push or git pull.","index":17,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"19.\n\n\nHOW DO YOU SWITCH BRANCHES USING GIT CHECKOUT?","answer":"To switch branches in Git, use the git checkout command followed by the branch\nname. Git automatically updates the working directory to the latest commit on\nthe new branch.\n\nIt's important to understand that this command has other important applications.\nWhen used with a specific file or path, it can restore the file to the state of\nthe latest commit on the current branch vs. pointing the HEAD to a specific\ncommit or tag.\n\n\nBASIC SYNTAX\n\n * Switch to an Existing Branch:\n   \n   git checkout existing-branch\n   \n\n * Create a New Branch and Switch to It:\n   \n   git checkout -b new-branch\n   \n\n * Interactively Select Changes to Stage:\n   \n   git checkout -p\n   \n\n * Restore a Specific File to the State of the Latest Commit on the Current\n   Branch:\n   \n   git checkout -- some-file\n   \n\n\nCONSIDERATIONS\n\n * Detached HEAD Mode: If you're not on the latest commit of your branch\n   (usually after a git checkout [commit]), you'll be in \"detached HEAD\" state.\n * Changes on Your Current Branch: If you have modified files, unstaged commits,\n   or untracked files, Git might warn you. You can either commit or stash\n   changes or override with the --force flag - use it with caution as it will\n   discard your local changes.\n\n\nBEST PRACTICES\n\n * Prioritize Safe Checkout: Prefer using git switch and git restore if your Git\n   version supports it (2.23 and later) for enhanced safety and comprehension.\n   They have specialized functions and are more self-explanatory.\n * Avoid Forceful Switch: Adding the --force flag can lead to loss of local\n   changes. It's best to use it sparingly and with caution.","index":18,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"20.\n\n\nWHAT IS THE PURPOSE OF GIT MERGE?","answer":"Git Merge serves to integrate changes from one branch into another. It's a\ncommon strategy for managing concurrent, separate lines of development, such as\nfeature branches.\n\n\nKEY COMPONENTS OF GIT MERGE\n\n * Base Commit: Also known as the common ancestor, this is a specific commit\n   where the two branches diverged.\n\n * Branch Head: References the latest commit on the branch you want to merge.\n\n * Merge Commit: A unique commit that ties together the histories of the merged\n   branches. It has at least two parent commits.\n\n\nBASIC MERGE TYPES\n\n * Fast-Forward Merge: When the target branch (where you're merging) is directly\n   ahead of the source branch. This can result in a linear history.\n\n * Three-Way Merge: More common. It identifies the base commit and integrates\n   changes from both branches.\n\n\nGIT MERGE IN ACTION\n\nHere is the demonstration git commands:\n\n# Start with a clean slate\ngit init\necho \"Line 1\" > file.txt\ngit add file.txt\ngit commit -m \"Initial commit\"\n\n# Simulate the first branch\ngit checkout -b branch-1\necho \"Line 2\" >> file.txt\ngit commit -am \"Added line 2\"\n\n# Simulate the second branch\ngit checkout master  # Or checkout the main branch if you're using it.\necho \"Line 3\" >> file.txt\ngit commit -am \"Added line 3\"\n\n# Merge branch-1 into master\ngit merge branch-1\n\n\n\nCLEAR VISUAL REPRESENTATION WITH COMMIT GRAPH\n\nThe commit graph is a visual representation that shows the history and\nrelationships between branches. It's especially helpful when navigating complex\nrepositories with multiple branches and ongoing development.","index":19,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"21.\n\n\nEXPLAIN THE GIT WORKFLOW YOU USE MOST FREQUENTLY.","answer":"As a developer, I often employ the Feature Branch Workflow. This approach's\ninherent modularity makes it particularly suitable for team-based and complex\nprojects.\n\nThe workflow relies on segregating feature development into distinct branches\nbefore merging them into a communal main branch.\n\n\nMAIN BRANCH\n\nThe main branch serves as the project's single source of truth. This branch is\nalways production-ready, which ensures that any codebase obtained from it is\nstable and free from errors. We also frequently refer to it as master.\n\n\nFEATURE BRANCHES\n\nEvery new feature or bug fix is developed in an isolated branch. This separation\npromotes version control and helps prevent conflicts with the primary codebase.\n\nBefore a feature branch is merged into main, it undergoes review and testing —\nensuring any changes are compatible and do not break the main branch.\n\nBEST PRACTICES\n\n 1. Naming: I apply a consistent naming convention, often incorporating the\n    associated issue or feature for easy tracking.\n 2. Duration: Feature branches are meant to be short-lived, encouraging swift\n    development and integration.\n 3. Version Control: Commits within feature branches are comprehensive and keep\n    the codebase in a functional state.\n\n\nMERGING STRATEGY\n\nMy preferred merging strategy is rebase and merge. It affords a linear and\ntidier commit history, eliminating unnecessary merge commits.\n\nWHY REBASE-AND-MERGE?\n\n * Clarity: It streamlines the commit history, offering a clearer, more linear\n   narrative.\n * Conflict Resolution: It identifies and pinpoints conflicts, specifically when\n   integrating feature branches into the main branch.","index":20,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"22.\n\n\nCAN YOU DESCRIBE THE PROCESS OF CREATING A NEW BRANCH AND MERGING IT BACK INTO\nTHE MAIN BRANCH?","answer":"Creating a new branch and merging it back into the main branch involves several\nsteps. The main objective is to allow for parallel development and to integrate\nchanges seamlessly.\n\n\nKEY STEPS\n\n 1. Create a New Branch: Use the git command checkout -b <branch-name> to create\n    a new branch and switch to it.\n    \n    git checkout -b new-feature\n    \n\n 2. Work on the New Branch: Make code changes, add new files, and commit your\n    changes.\n    \n    git add .\n    git commit -m \"New feature: XYZ\"\n    \n\n 3. Update the Main Branch: Before merging, I recommand to sync your main branch\n    (previously known as master) with the latest upstream changes.\n    \n    git checkout main\n    git pull origin main \n    \n\n 4. Merge the New Branch into Main: Once on the main branch, use the command\n    merge --no-ff to merge the changes from the new branch in. This ensures a\n    new merge commit is created.\n    \n    git merge --no-ff new-feature\n    \n\n 5. Resolve Any Conflicts: If there are conflicting changes, resolve them in\n    your working directory, and then add and commit those changes.\n    \n    git add .\n    git commit -m \"Resolved merge conflicts\"\n    \n\n 6. Push Main Branch to Origin: After merging, push the main branch to the\n    remote repository.\n    \n    git push origin main\n    \n\n 7. Delete the Feature Branch: It's good practice to delete the feature branch\n    after merging it into the main branch.\n    \n    git branch -d new-feature\n    \n\n 8. Also, Push Deletion to the Remote: To delete the branch from the remote\n    repository, use:\n    \n    git push origin --delete new-feature\n    \n\n\nVISUAL REPRESENTATION\n\nGit Workflow\n[https://firebasestorage.googleapis.com/v0/b/dev-stack-app.appspot.com/o/git%2F2.%20git-flow.png?alt=media&token=6aa8d5f7-a1ae-4905-bbee-9b7061c3051c&_gl=1*wq3ugq*_ga*OTYzMjY5NTkwLjE2ODg4NDM4Njg.*_ga_CW55HF8NVT*MTY5NzI1Njg4MC4xNDUuMS4xNjk3MjU2OTg5LjU0LjAuMA..]","index":21,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"23.\n\n\nWHAT IS A MERGE CONFLICT IN GIT AND HOW DO YOU RESOLVE IT?","answer":"Merge conflicts in Git occur when the version control system cannot\nautomatically resolve differences between two commits. Conflicts usually arise\nwhen the same lines of a file are modified in both the source and target\nbranches of a merge operation.\n\n\nCOMMON SETUP FOR DEMONSTRATING MERGE CONFLICTS\n\nHere is a simple \"conflict-demo\" setup:\n\n 1. Initialize a Git Repository:\n    \n    mkdir conflict-demo\n    cd conflict-demo\n    git init\n    \n\n 2. Create 'conflict.txt' and Add Initial Content:\n    \n    conflict.txt:\n    \n    This line is common.\n    \n    <<<<<<< HEAD\n    This line is only in the main branch.\n    =======\n    This line is only in the feature branch.\n    >>>>>>> feature\n    \n    \n    Initially, both the main and feature branches have the above version of this\n    file.\n\n 3. Commit the Initial Version:\n    \n    git add conflict.txt\n    git commit -m \"First commit - Initial text in conflict.txt\"\n    \n\n\nSTEPS TO RESOLVE MERGE CONFLICTS\n\n 1. Start Merging:\n    \n    * First, ensure that you are on the branch where you want to merge changes.\n      In our example, let's merge the feature branch into the main branch.\n      \n      git checkout main\n      git merge feature\n      \n\n 2. Conflict Emergence:\n    \n    * The above merge command leads to a merge conflict due to differing lines\n      in 'conflict.txt'.\n\n 3. Conflict Indication:\n    \n    * Open the file 'conflict.txt' after the failed merge. Git visualizes\n      conflicting sections.\n    \n    conflict.txt:\n    \n       This line is common.\n    \n    <<<<<<< HEAD\n       This line is only in the main branch.\n    =======\n       This line is only in the feature branch.\n    >>>>>>> feature\n    \n    \n    After visualizing the conflict, let's proceed with resolving it.\n\n 4. Resolve Conflict\n    \n    You need to edit the 'conflict.txt' file to manually remove the conflict\n    markers (<<<<<<<, =======, and >>>>>>>) and adjust the content to how you\n    want it. Here is the resolved content:\n    \n        This line is common.\n        This line is only in the feature branch.\n    \n\n 5. Mark Conflicts as Resolved:\n    \n    After manually resolving the conflict, git add is used to indicate the\n    resolved file to Git:\n    \n    git add conflict.txt\n    \n\n 6. Finalize Merge:\n    \n    With the conflict resolved, complete the merge operation:\n    \n    git merge --continue\n    \n\n 7. Confirm Merge:\n    \n    Verify the successful merge:\n    \n    git status\n    \n    \n    If everything went smoothly, Git confirms that you're up to date with the\n    remote branch.\n\n 8. Cleanup:\n    \n    Optionally, you can delete the feature branch:\n    \n    git branch -d feature\n    \n    \n    In a team environment, it's often practical to push the updated main branch\n    to the remote-repository.\n    \n    git push origin main\n    \n\n\nSIMPLIFYING CONFLICT RESOLUTION WITH VISUAL TOOLS\n\nSeveral Visual Studio Code and VCS (Version Control Systems) have built-in\nfunctions that can help you manage merge conflicts.\n\nConflict Resolution in Visual Studio Code\n[https://firebasestorage.googleapis.com/v0/b/dev-stack-app.appspot.com/o/git-interview-q-a%2Fvisual-studio-git.jpg?alt=media&token=be6f2354-439e-441c-a6b5-554f070f6d8f]","index":22,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"24.\n\n\nWHAT IS A FAST-FORWARD MERGE IN GIT?","answer":"A fast-forward merge is a Git merging strategy that's simple and direct. It\ninvolves moving a branch pointer with no diverging commits, making it a linear\nhistory.\n\nHere's a visual representation:\n\n  A---B---C  (master)\n       \\\n        D---E  (feature)\n\n\nIn a Fast-Forward merge, the goal is to bring all changes from the feature\nbranch into the master. Instead of creating a merge commit (bubble), Git moves\nthe master pointer to the latest commit of the feature branch. The entire\nsequence of commits from 'feature' will now be part of 'master'.\n\n# Before merge, 'master' is at C, and 'feature' is at E\n  O---O---O---O---O  (master, feature)\n\n# After the fast forward merge\n  O---O---O---O---O---O  (master, feature)\n\n\n\nADVANTAGES AND DISADVANTAGES OF FAST-FORWARD MERGE\n\n * Pros:\n   \n   * Clean history: No merge commits keep history linear.\n   * Simplicity: It's quick and looks tidy.\n   * No unnecessary commits: Avoids a cluster of temporary commits.\n\n * Cons:\n   \n   * Potential loss of context: Developers might not understand why certain\n     changes were introduced if the history is too linear.\n   * Possible data loss: Prior commits on 'master' since the point of divergence\n     can be obscured.\n   * Lack of atomicity: If part of the changes from the feature branch is\n     desirable, rolling back can be tricky.\n\n\nWHEN TO USE FAST-FORWARD MERGES\n\n * In small teams: It offers a straightforward process when coordination isn't a\n   significant concern between team members.\n * For short-lived feature branches: Feature branches that are recently created\n   can be quickly and neatly integrated.\n * In solo projects: Since maintenance of history isn't a significant concern.\n\n\nCODE EXAMPLE: FAST-FORWARD MERGE\n\nHere is the Git command to do a Fast-Forward Merge:\n\ngit checkout master\ngit merge feature\n","index":23,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"25.\n\n\nDEFINE A THREE-WAY MERGE.","answer":"Three-way merge, common in version control systems like Git, aims to reconcile\ndifferences between three versions of the same file:\n\n * Base Version: Often the most recent common ancestor of the two other\n   versions.\n * Local Version: The version in your local branch.\n * Remote Version: The version in the branch you're merging into.\n\nThe three-way merge involves comparing:\n\n 1. The Base and the Remote to find out what changes have been made to the file\n    on the branch we’re merging into.\n 2. The Base and the Local to determine what changes you've made to the file in\n    your branch.\n\nThe goal is to combine these changes seamlessly.\n\n\nTHE ROLE OF VERSION CONTROL SYSTEMS\n\nIn Git:\n\n * The base version is your common ancestor.\n * The \"remote\" version is what's currently on the branch you're merging into\n   (origin/master or similar).\n * The \"local\" version is what's currently on your branch (master or similar).\n\n\nMECHANISM OF THREE-WAY MERGE\n\n * File Comparison: Git compares the three versions to discern what changes have\n   been made to each.\n * Conflict Detection: If the same lines have been changed in different ways in\n   both the remote and local versions, a merge conflict is flagged. Otherwise,\n   the changes are automatically merged, and the file is updated.\n * Version Commit: After the three-way merge, Git creates a new commit on your\n   branch, unifying the changes from both branches.\n\n\nMERGE TYPES\n\nGit doesn't necessarily execute a three-way merge every time you merge branches.\nIt has various strategies, such as:\n\n * Fast-Forward Merge: If the base is still the latest commit on the branch\n   you're merging into, Git can simply move the branch pointer forward to the\n   latest commit on your branch.\n * Squash Merge: Rather than integrating individual commits, a squash merge\n   combines all the changes in your branch into a single new commit before\n   adding it to the destination branch.\n\n\nPROS AND CONS\n\nPROS\n\n * Efficiency: Saves time and reduces the risk of errors.\n * History Preservation: Clearly indicates where your branch diverged from the\n   target branch.\n * Content Focused: Emphasizes how content changed over time rather than just\n   when it changed.\n\nCONS\n\n * Potential Complexity: Merge conflicts can be intricately challenging to\n   resolve, even with automated tools.\n * Requires Context: It's crucial to understand the changes made in your branch\n   and in the target branch before proceeding with the merge.\n\n\nEXAMPLE: THREE-WAY MERGE IN CONTEXT\n\nSCENARIO\n\nConsider your local repository (BBB) and a remote repository (origin/master-\nAAA). You clone the remote repository and create a new branch feature (CCC) from\nit. Meanwhile, updates are made to master on the remote repository (DDD).\n\nSEQUENCE\n\n 1. Clone & Branch:\n    * AAABBB{A,B,C,D}\\{A, B, C, D\\}{A,B,C,D} -> AAABBB{A,B,C,D}\\{A, B, C,\n      D\\}{A,B,C,D}\n 2. Locally Edit:\n    * AAABBB{A,B,C,D,G}\\{A, B, C, D, G\\}{A,B,C,D,G} Locally ->\n      AAABBB{A,B,C,D,G}\\{A, B, C, D, G\\}{A,B,C,D,G}\n 3. Remote Update:\n    * AAABBB{A,B,C,D,D′}\\{A, B, C, D, D'\\}{A,B,C,D,D′} Remote ->\n      AAABBB{A,B,C,D,D′}\\{A, B, C, D, D'\\}{A,B,C,D,D′}\n 4. Merge:\n    * AAABBB{A,B,C,D,D′,G}\\{A, B, C, D, D', G\\}{A,B,C,D,D′,G}\n\nTechnically, the three-way merge is happening between AAA, BBB, and\n{A,B,C,D}\\{A, B, C, D\\}{A,B,C,D}.","index":24,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"26.\n\n\nHOW DO YOU REBASE A BRANCH IN GIT?","answer":"Rebasing a Git branch involves moving its history to a new base commit. This\nresults in a linear sequence of commits, making commit history in the project\nclearer.\n\n\nSTEPS FOR BRANCH REBASE\n\n 1. Update Your Source Branch: Start by ensuring your local repository is\n    updated. It's especially important in collaborative environments to\n    incorporate any changes made on the upstream branch. Use:\n    \n    git checkout source-branch\n    git pull origin source-branch\n    \n\n 2. Start the Rebase: Move to the target branch (the one you want to be the new\n    base) and initiate the rebase.\n    \n    git checkout target-branch\n    git rebase source-branch\n    \n    \n    If merging conflicts occur during the rebase, resolve them before\n    continuing.\n\n 3. Verify & Update the Source Branch: For best practices, go back to the source\n    branch and ensure it includes all changes from the target branch.\n    \n    git checkout source-branch\n    git rebase target-branch\n    \n\n 4. Update Remote: If your source-branch is remote and you've performed a rebase\n    on it, you'll need to overwrite the remote with the updated history, which\n    can be done by forcing the push.\n    \n    git push origin source-branch --force\n    \n    \n    Caution: Be careful when using --force, as it overwrites the remote branch's\n    history.\n\n 5. Common Pitfalls to Avoid: While rebasing, ensure your historical changes\n    don't impact others. If the branch is shared, communicate with the team and\n    agree on a rebase strategy to avoid complications.\n\n 6. Finish Up: When you're confident with the changes, your source-branch is\n    updated, and everything looks good after resolving any conflicts, you're\n    ready to complete the rebase.\n    \n    git checkout target-branch\n    git merge source-branch     # Optional, if you want to update target-branch\n    \n\n\nBEST PRACTICES FOR REBASING\n\n * Know Project Dynamics: Understand the Git strategy used in the project.\n   Different approaches, such as merge commit and rebase, can be used.\n * Regular Commits: Make smaller, more focused commits instead of large,\n   sweeping ones to simplify the review process and minimize the chance of\n   conflicts.\n * Limit to Local Commits: For shared branches, it's best not to rebase commits\n   you've already pushed. This helps avoid inconveniencing other team members.\n\n\nREBASE VS. MERGE: PROS AND CONS\n\nREBASE\n\n * Pros: Linear history, cleaner, and easier to follow than multiple merge\n   commits.\n * Cons: Can cause diverge issues if not used properly in a shared environment.\n\nMERGE\n\n * Pros: Easier to use in a shared environment, as it doesn't alter the commit\n   history.\n\n * Cons: Can lead to a cluttered history, especially if used excessively where\n   simpler solutions suffice.","index":25,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"27.\n\n\nEXPLAIN THE PROS AND CONS OF REBASING VS. MERGING.","answer":"Rebasing and Merging both offer solutions for integrating code changes in Git,\neach with its own advantages and drawbacks.\n\n\nKEY DISTINCTIONS\n\n 1. Rebase: Reapplies your local changes on top of the updated commit history of\n    the branch you're rebasing to.\n\n 2. Merge: Integrates changes from a source branch into a target branch,\n    resulting in a new commit.\n\n\nTHE PROS AND CONS\n\nMERGING\n\n * Pros:\n   \n   * Preserves Individual Histories: The commits you merge are kept separate,\n     which can be visually distinct in the commit history.\n   * Simplified Collaboration: Prolific commit histories from collaborative\n     teams can more easily be understood without rebasing complexities.\n\n * Cons:\n   \n   * Redundant Commits: Frequent merge commits might clutter the commit history\n     with less meaningful detail.\n   * Timeline Complexity: It can be harder to identify the exact order of\n     changes relative to the source branch.\n\n\nMERGING IN ACTION\n\nEXAMPLE GIT WORKFLOW\n\n 1. Setup: Assuming you're on a new feature branch.\n\n 2. Task: Make a few commits.\n\n 3. Execution: Merge the feature branch back into the main branch.\n\n 4. Code:\n    \n    # On the feature branch\n    git add .\n    git commit -m \"Implement feature XYZ.\"\n    \n    # Merge into the main branch\n    git checkout main\n    git merge feature-branch\n    \n\n 5. Result: Notice the new merge commit on your main branch.\n\nREBASING\n\n * Pros:\n   \n   * Linear History: The commit history appears linear without merge commits,\n     making it easier to follow.\n   * Aesthetic Clarity: Discards less meaningful intermediary commits, leading\n     to a cleaner history.\n\n * Cons:\n   \n   * Potential Branch Conflicts: If multiple branches are based on the commits\n     being rebased, it can lead to conflict resolution in multiple places.\n   * Shared Repositories: Can create inconsistencies in shared repositories if\n     not carried out carefully.\n\n\nREBASING IN ACTION\n\nEXAMPLE GIT WORKFLOW\n\n 1. Setup: On your feature branch.\n\n 2. Task: Make a few commits.\n\n 3. Execution: Rebase your feature branch onto the main branch.\n\n 4. Code:\n    \n    # On feature branch\n    git add .\n    git commit -m \"New commit for rebase.\"\n    \n    # Rebase onto the main branch\n    git rebase main\n    \n\n 5. Result: The commit history is now cleaner and linear.","index":26,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"28.\n\n\nWHAT IS THE PURPOSE OF GIT TAG?","answer":"Git tags serve as pointers to specific commit snapshots, commonly used to mark\nsoftware versions or significant milestones. Unlike branches, which move with\neach new commit on that branch, tags are static and typically used for release\nmanagement.\n\nBranches are often referred to as movable pointers to commits, whereas tags are\nlike bookmarks or snapshots that are fixed to a specific commit.\n\n\nPRACTICAL APPLICATION\n\n * Version Control: Each major release and often minor ones are tagged for easy\n   reference. It allows for tracking bugs or function changes throughout the\n   software's development.\n\n * Release Management: When a software version is ready to be released to\n   end-users or for specific tests, a tag efficiently delineates the set of\n   commits belonging to that version.\n\n * Working with Teams: Git tags serve as a communication tool. Team members can\n   quickly understand what version a tag refers to and concentrate their efforts\n   accordingly.\n\n\nSAFETY MECHANISMS\n\nGit tags are immutable to safeguard against unintentional changes.\n\nWhen creating tags, Git employs the same hash function it uses for committing\nchanges, ensuring data integrity. If a commit corresponding to a tag is changed,\nthe tag will point to the original commit, alerting developers to the\ndiscrepancy.\n\n\nCOMMON TAG TYPES\n\n * Lightweight: Essentially a pointer to a specific commit. No metadata, such as\n   tagger's name or email, or tagging date and message, is saved. Lightweight\n   tags are created using just the tag name, which makes them relatively easy to\n   create and delete.\n\n * Annotated: A more feature-rich type that includes extra metadata. This\n   metadata typically comprises the tagger, the tagging date, and an optional\n   annotation message. Annotated tags are considered more powerful and useful,\n   especially for releases. They offer more context about the tag and the\n   release it represents.\n\n\nGIT COMMANDS\n\n * Create a Tag:\n   \n   * Annotated: git tag -a <tagname>\n   * Lightweight: git tag <tagname>\n\n * Verify Tag: git show <tagname> provides details\n\n * Push Tag to Remote: git push origin <tagname>\n\n * Push All Tags to Remote: git push --tags\n\n * Delete Tag: git tag -d <tagname> and, if already pushed, git push origin\n   --delete <tagname>\n\nNote: Remote repositories also require retrieving tags, which is done through:\ngit fetch --tags.","index":27,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"29.\n\n\nHOW DO YOU REVERT A COMMIT THAT HAS ALREADY BEEN PUSHED TO THE REMOTE\nREPOSITORY?","answer":"Reverting a commit that has already been pushed to the remote repository\nrequires a multi-step process that includes using the git revert command.\n\n\nREVERTING A PUSHED COMMIT\n\n 1. Create a New Branch: The new branch is where you'll make and test your\n    revert.\n    \n    git checkout -b <branch-name>\n    \n\n 2. Revert the Commit: Use the git revert command to create a new commit that\n    undoes the changes from a specific commit or a range of commits.\n    \n    git revert <commit-hash>\n    \n    \n    If there are merge conflicts, resolve them and continue the process with:\n    \n    git commit\n    \n\n 3. Push the Revert to Remote: Push the branch with the revert commit to your\n    remote repository.\n    \n    git push origin <branch-name>\n    \n\n 4. Open a Pull Request (Optional): On GitHub, for example, you can open a pull\n    request to merge your revert branch into the original branch, giving others\n    a chance to review the changes before merging.\n\n 5. Monitor and Handle Potential Conflicts: If there are conflicts during the\n    merge, resolve them and push the changes.\n\n 6. Perform Additional Testing (Optional): It's good practice to ensure that the\n    unintended changes are indeed reverted before merging back.\n\n\nBEST PRACTICES FOR REVERTING COMMITS\n\n * Commit Responsibly: Each commit should represent a cohesive and functional\n   change.\n * Communicate Changes: Especially when collaborating with a team, inform others\n   about the revert and the reason behind it.\n * Stay Consistent: If the change you are reverting was part of a code cleanup,\n   your revert commit should follow suit.","index":28,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"30.\n\n\nWHAT IS THE SIGNIFICANCE OF THE MASTER BRANCH IN GIT?","answer":"In the Git system, master is a default branch that holds the most stable,\nproduction-ready version of the code. It is the point of reference and\nmanagement for team collaboration, Version Control, and releases.\n\n\nNOMENCLATURE\n\n * Master: A standard term in various systems representing the primary or main,\n   such as in databases, domain controllers, and version control systems.\n\n\nGIT INITIALIZED REPOSITORY\n\nAll newly created Git repositories initially have the master branch. It's\nimportant to note that this convention may evolve, with \"main\" becoming a more\ncommon naming standard.\n\nWhile GitHub and GitLab have transitioned to using default branches named\n\"main\", many older repositories still predominantly use \"master\". The exact\ndefault can be set during the repository creation process.\n\n * GitHub: Project setup lets individuals select the default branch name. If not\n   changed explicitly, it defaults to \"main\".\n * GitLab: The initial branch can be specified during creation.\n\n\nPUSHING AND PULLING CHANGES\n\nWhen working with a remote repository, more so one established before the \"main\"\ndefault became prevalent, it is typical to push and pull changes to and from the\n\"master\" branch. This action integrates new commits across all team members.\n\n\nCODE MANAGEMENT\n\n * Development: New features and changes stem from independent branches.\n * Merge to Master: After thorough testing, these new features and changes are\n   merged back into the master branch, which acts as the stable state.\n\n\nBEST PRACTICES\n\n * Branch Protection: Enhanced control mechanisms prevent direct pushing to\n   vital branches, like \"master\".\n * Code Reviews: Integral to ensuring changes are robust and align with project\n   objectives before they are merged into the master.\n\n\nTRANSITION TO \"MAIN\"\n\nThe technology community is progressively adopting the term \"main\" as the\nprimary branch in newer repositories due to its inclusive nature, aligning with\ndiversity and inclusion efforts.\n\nExisting repositories, especially those actively engaged in development, are\ntransitioning \"master\" branches to be named \"main\". This change shows a\nsensitivity to contemporary social and coding standards, acknowledging the\ndiverse nature of tech communities.\n\n\nCODE EXAMPLE: RENAMING BRANCH\n\nHere is the Git command:\n\ngit branch -m master main\n\n\nThis command renames the master branch to main locally. After renaming the local\nbranch, you need to push the changes:\n\ngit push -u origin main\n\n\nFrom Git 2.28, you can use git init or --initial-branch at repository creation\nto specify the default branch name retrospectively.","index":29,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"31.\n\n\nWHAT IS A DISTRIBUTED VERSION CONTROL SYSTEM AND HOW DOES GIT FUNCTION AS ONE?","answer":"Git operates as a specialized form of version control system (VCS) known as a\ndistributed VCS (DVCS). This approach diverges from conventional VCS, such as\nSubversion, which boasts a central repository.\n\n\nROLE OF CENTRAL REPOSITORY\n\nWhile it's true that Git does have a centralized server (like GitHub, GitLab, or\nBitbucket), this server doesn't serve as the \"single source of truth\" about the\ncodebase. Instead, it acts as:\n\n * A point for shared reference\n * A means to facilitate collaboration\n\n\nDATA FLOW IN A GIT WORKFLOW\n\n 1. Check-Out: Each developer creates a local copy of the entire repository.\n 2. Isolation: Developers work independently in their local setups.\n 3. Save Changes: Developers store changes in their local repository.\n 4. Synchronization: As required, developers share changes with the central\n    server and pull in updates from others.\n\n\nCODE EXAMPLE: CENTRALIZED WORKFLOW\n\nHere is the Java code:\n\npublic class CentralizedWorkflow {\n    public static void main(String[] args) {\n        System.out.println(\"Welcome to Centralized Version Control!\");\n    }\n}\n\n\n\nBENEFITS OF DISTRIBUTED VERSION CONTROL\n\n 1. Localized Control: Each developer has a full history of the project\n    available locally.\n 2. Effectiveness: Code tracking actions, such as commit, branch, and merge, are\n    typically faster in a local context.\n 3. Reduced Dependence: The system remains functional, even in the absence of\n    the central server. Developers can commit changes freely without an internet\n    connection.","index":30,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"32.\n\n\nDESCRIBE THE GIT FEATURE BRANCH WORKFLOW.","answer":"Feature Branch Workflow is a widely adopted version control strategy that\nleverages the Git branching system. It provides an organized approach for\ncollaborative and individual development, effectively managing features and bug\nfixes.\n\n\nKEY PRINCIPLES\n\n * Atomic Commits: Each commit should represent a single functional change.\n * Code Review: Team members review changes before merging into the main branch.\n * Continuous Integration: Automates verification of every feature-branch\n   change, enhancing reliability.\n\n\nWORKFLOW STEPS\n\n 1. Branch Off: Create a dedicated Git branch for the new feature or bug fix.\n 2. Code & Commits: Make code changes on the feature branch, committing\n    iteratively.\n 3. Rebase & Resolve: Incorporate any upstream changes and resolve conflicts.\n 4. Test: Validate changes locally before pushing the branch.\n 5. Code Review: Engage in collaborative review, ensuring quality.\n 6. Merge into Master/Develop: Integrate the feature branch into the main branch\n    ('master' or 'develop') after approval.\n\n\nVISUAL REPRESENTATION\n\nFeature Branch Workflow\n[https://firebasestorage.googleapis.com/v0/b/dev-stack-app.appspot.com/o/version-control%2Fworkflows%2Ffeature-branch.svg?alt=media&token=278e905b-14b0-42cc-800b-92e14fb324b7&_gl=1*11o2cms*_ga*OTYzMjY5NTkwOTY3Nzg5NzU3Njg.*_ga*C1NTHmBUq912MxYT7AAAogriGRIWYA]\n\n\nCODE EXAMPLE: FEATURE BRANCH WORKFLOW\n\nHere is the code:\n\n  # Clone a repository - if not already done\n  git clone <repository_url>\n  \n  # Move to the main branch for changes\n  git checkout master\n  \n  # Fetch the latest changes of the parent branch\n  git pull\n  \n  # Create and move to a feature branch\n  git checkout -b feature-user-authentication\n  \n  # Make changes, then add and commit\n  git add .\n  git commit -m \"Implemented user authentication logic\"\n  \n  # Rebase to integrate any new changes from master\n  git checkout master\n  git pull\n  git checkout feature-user-authentication\n  git rebase master\n  \n  # After rebasing, handle any potential conflicts, commit if needed, then push to remote\n  git push --force\n  \n  # Merge the feature branch back into the main branch\n  git checkout master\n  git merge feature-user-authentication\n  \n  # Verify and then push to remote branch (if no issues)\n  git push\n  \n  # Lastly, delete the feature branch\n  git branch -d feature-user-authentication\n\n\n\nBENEFITS\n\n * Isolation: Reduces the impact of incomplete or buggy features.\n * Collaboration: Empowers developers to work in parallel.\n * Historical Clarity: Improved commit history with labeled feature branches.\n * Segregation of Concerns: Ensures mainline branches stay production-ready.\n\n\nPOSSIBLE PITFALLS\n\n * Code Drift: Frequent updates on the main branch may trigger numerous\n   conflicts.\n * Procrastination: Lengthy feature-branch lifecycles can impede progress.\n * Silent Changes: Untested or unreviewed changes might get merged.\n\nWHEN TO USE FEATURE BRANCH WORKFLOW\n\n * Team Collaboration: Ideal for projects where multiple developers have\n   overlapping responsibilities.\n * Risk Aversion: Ensures stable main branches by isolating untested features.\n * Continuous Deployment: Ascertains that commits to the main branch undergo\n   rigorous testing and validation.","index":31,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"33.\n\n\nEXPLAIN THE GITFLOW WORKFLOW.","answer":"Gitflow is a popular Git workflow designed for larger development teams. It uses\n\"islands\" of stability, with multiple long-lived branches. It is tailored for\nstability first, and its somewhat complex structure can require discipline to\nmaintain.\n\n\nCORE BRANCHES\n\n * Master: Represents the latest, stable production release. Direct commits\n   aren't made here but come from the develop and release branches.\n * Develop: Focuses on integrating features, serving as a bleeding-edge staging\n   area. Feature branches merge into develop.\n\n\nSUPPORTING BRANCHES\n\n * Feature Branches: Isolated for each new feature. Merges into develop once the\n   feature is complete.\n\n * Release Branches: Serve as stabilization areas for upcoming releases. All\n   pre-release tasks, such as final testing and documentation, are performed\n   here. Once thoroughly validated, the release merges into master and develop,\n   and the release branch is closed.\n\n * Hotfix Branches: Task-specific branches for immediate fixes needed in the\n   master branch. Directly branched off of master and merged back into both\n   master and develop. Once the hotfix is complete, it is merged quickly back\n   into master and further integrated into develop. A hotfix branch is closed\n   after merging.\n\n\nBENEFITS\n\n * Discipline Through Formal Gates: master and release ensuring stability before\n   an integration occurs.\n * Feature Completeness: Features are grouped, thereby making sure that\n   incomplete or unstable features are not integrated into develop.\n\n\nCHALLENGES\n\n * Complexity: Has multiple long-lived branches and strict rules about how code\n   is integrated moving through different stages.\n\n * Over-reliance on Release Branches: In some contexts, such branches might not\n   be necessary.\n\n\nWHEN TO CHOOSE GITFLOW\n\n * Team Maturity: Ideal for experienced teams with well-defined release cycles.\n * Stability: Primarily for projects where crucial feature stability is\n   essential.\n * Formal Release Processes: Useful in scenarios that require comprehensive\n   release management.\n\n\nCODE EXAMPLE: GITFLOW COMMANDS\n\nHere is the git command:\n\n# Initialize a Gitflow repository\n$ git flow init\n\n# Begin a new feature\n$ git flow feature start my-feature\n# Finish up a feature\n$ git flow feature finish my-feature\n\n# Start a release\n$ git flow release start 1.0\n# Finish a release, merges into master and develop, and then tags the release\n$ git flow release finish 1.0\n\n# Hotfixes are started just like releases, and then finished like a feature\n","index":32,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"34.\n\n\nWHAT IS A FORKING WORKFLOW IN GIT?","answer":"The Forking Workflow in Git is especially common in open-source projects hosted\non platforms like GitHub. It centers around the concept of a public repository,\nfrom which external contributors fork their own copies. After making changes,\nthese contributors submit a pull request for the maintainers' review.\n\n\nCORE PRINCIPLES\n\n 1. Public Repository: The main project is accessible to all but is not directly\n    writable to maintain control and quality.\n\n 2. Forking: External contributors create a personal, writable version of the\n    main project.\n\n 3. Pull Requests: Any modifications from the contributors must be solicited and\n    reviewed before merging.\n\n 4. Cloning and Remotes: Contributors work from their personal fork, while the\n    project owners and other team members work from the main repository.\n\n\nKEY BENEFITS\n\n * Centralized Integrity: The main repository is safeguarded, ensuring that\n   contributions meet project standards.\n\n * Separation of Concerns: Each contributor is free to work in their fork\n   without interfering with others.\n\n * Transparency and Attribution: All contributions are recorded in the central\n   repository, providing a clear history of changes and their origin.\n\n\nBEST PRACTICES\n\n * Upstream Reference: Set up the main repository as the \"upstream\" remote. This\n   allows for syncing with the main project for any subsequent changes made by\n   other contributors or maintainers.\n\n * Continuous Integration: For more stringent controls, integrate with CI tools\n   that run automated checks and tests on proposed changes before merging.\n\n * Clear Documentation and Communication: Establish guidelines for contributors\n   and maintainers to ensure efficient collaboration.\n\n\nINTERACTION FLOW\n\n 1. Fork: A contributor creates their fork of the main repository.\n\n 2. Clone: The contributor then clones their fork to their local system to work\n    on the changes.\n\n 3. Commits: After making the necessary changes, the contributor commits the\n    modifications to their local repository.\n\n 4. Push: The contributor pushes the changes to their fork on the remote server.\n\n 5. Pull Request: The contributor initiates a pull request to the main project,\n    requesting that the changes be merged.\n\n 6. Review and Merge: Project maintainers or designated reviewers inspect the\n    modifications and, if satisfactory, integrate them into the main repository.\n\n 7. Local Update: If the pull request is approved, the original contributor may\n    need to sync their fork with the main repository before continuing their\n    work.\n\n\nPRACTICAL EXAMPLE\n\nGITHUB REPOSITORY SETUP\n\n 1. Fork the Repository: An external contributor forks the main repository on\n    GitHub, creating their version of the project.\n\n 2. Clone the Fork: The contributor clones their forked repository to their\n    local development environment using the command:\n    \n    git clone https://github.com/external-contribution/project.git\n    \n\n 3. Add a Remote for Upstream: To track the main repository, one-time setup is\n    required using the command:\n    \n    git remote add upstream https://github.com/original-project/project.git\n    \n\nROUTINE WORKFLOW\n\n 1. Start with the Latest: To stay updated with any changes from the main\n    repository, the contributor runs:\n    \n    git pull upstream main\n    \n\n 2. Create a New Branch: Development is usually isolated in feature-based\n    branches to avoid conflicts, like so:\n    \n    git checkout -b new-feature\n    \n\n 3. Make Changes and Commit: The contributor works on the intended modifications\n    and uses:\n    \n    git add .\n    git commit -m \"Description of changes\"\n    \n\n 4. Push Changes to the Fork: The local changes are pushed to the contributor's\n    fork on the remote server:\n    \n    git push origin new-feature\n    \n\n 5. Initiate Pull Request: On their forked repository on GitHub, the contributor\n    selects the new branch and starts a pull request to the main project.\n\n 6. Review and Merge: The project maintainers review the pull request on the\n    main repository and, if accepted, merge the changes into the project.\n\n 7. Update Local and Remote Forks: Once the pull request is merged, the\n    contributor should update their local and remote forks to reflect the\n    changes in the main repository:\n    \n    git checkout main\n    git pull upstream main\n    git push origin main\n    \n\n\nVERSION CONTROL PLATFORM SUPPORT\n\nWhile the Forking Workflow is widely used in GitHub and other similar platforms,\nit can be adapted for use with most version control systems like Bitbucket or\nGitLab.","index":33,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"35.\n\n\nDISCUSS THE CENTRALIZED WORKFLOW IN GIT.","answer":"The Centralized Workflow is a straightforward Git strategy typically used in\nsmaller teams or on simpler projects.\n\nUnder this workflow, there is a single, central repository that serves as the\n\"single source of truth\" for all changes. Developers clone the central\nrepository, make their changes locally, and then push them to update the central\nstate.\n\n\nKEY COMPONENTS\n\n * Master Branch: This is the default branch that serves as the main line of\n   development. It's typically locked to ensure code stability.\n\n * Feature/Branch Workflow: Developers work on their features in local,\n   topic-specific branches. Once tested, they merge these branches into the\n   master and push the changes to the central repository.\n\n\nCORE ACTIONS\n\n * Clone: Developers make a local copy of the central repository.\n * Pull (Fetch & Merge): To retrieve the latest changes from the central\n   repository.\n * Commit & Push: After making changes, developers commit them locally and then\n   push those commits to update the central repository.\n\n\nRATIONALE\n\n * Simplicity: Easy to set up and understand, making it ideal for those new to\n   version control systems or teams with less complex projects.\n\n * Stability: The master branch represents the latest stable release, often used\n   as a baseline for deployment.\n\n\nLIMITATIONS\n\n * Rigid: Can lead to bottlenecks if multiple developers are constantly trying\n   to push new features to the master branch.\n\n * Scalability: Not the best choice for large, distributed teams or complex\n   projects.\n\n * Lack of Flexibility: Offers limited support for tasks like experimenting with\n   new ideas or maintaining multiple versions concurrently.\n\n\nBEST PRACTICES\n\n * Merge from Upstream: Before pushing your changes, make sure to pull the\n   latest updates to avoid potential conflicts.\n\n * Code Review: Incorporate a code review process before merging feature\n   branches to the master.\n\n * Test Before Merge: Ensure that the changes made in feature branches are\n   tested and work as expected before merging them into the master branch.\n\n\nVISUAL REPRESENTATION\n\nCentral Workflow\n[https://git-scm.com/book/en/v2/images/centralized-workflow.png]","index":34,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"36.\n\n\nEXPLAIN WHAT A REMOTE REPOSITORY IS IN GIT.","answer":"A remote repository in Git serves as a shared project hub, enabling\ncollaboration between team members. It typically resides on a server or a\ncentral location accessible to authorized users.\n\nKey distinctions of a remote repository include:\n\n\nROLE IN COLLABORATIVE WORKFLOWS\n\nThe remote repository acts as the focal point where team members exchange\nchanges. Different team members can have their local repositories on their own\nmachines.\n\n * Upstream Changes: Team members fetch or pull from the remote to sync with\n   changes made by others.\n * Downstream Changes: They then push their own changes for others to access.\n\n\nCOMMON HOSTING SOLUTIONS\n\nSeveral popular platforms like GitHub, GitLab, and Bitbucket provide hosting for\nGit remote repositories. They offer a range of features including issue\ntracking, project management, and more.\n\n\nBRANCH VISIBILITY\n\nRemote repositories often allow teams to segregate work by using different\nbranches. Master or main might be stable and ready for deployment, while feature\nbranches undergo ongoing development.\n\n\nCODE-REVIEW MECHANISMS\n\nRemote repositories support collaborative code review through mechanisms like\nPull Requests. When working with a feature branch, for example, a team member\nsubmits a pull request to signal that changes are ready for review and potential\nmerge into the main branch.\n\nGitHub introduced the \"Squash and Merge\" feature. I will provide a simple Python\ncode example.\n\n# main.py\ndef remote_repo_pull(request):\n    print(f\"Pulling changes from remote repository: {request}\")\n\ndef remote_repo_push(request):\n    print(f\"Pushing changes to remote repository: {request}\")\n\ndef code_review(pull_request):\n    print(f\"Performing code review for pull request: {pull_request}\")\n\ndef main():\n    remote_repo_pull(\"master\")\n    remote_repo_push(\"feature_branch\")\n    code_review(\"feature_branch\")\n\nmain()\n","index":35,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"37.\n\n\nDESCRIBE HOW YOU WOULD CHANGE A GIT REMOTE URL.","answer":"Changing the remote URL is a common task in collaborative coding. It can be\nespecially useful when you're setting up a project on a new hosting service or\nneed to shift to a fork.\n\n\nSTEPS TO CHANGE THE REMOTE URL\n\n 1. Verify Current Remotes: If you don't remember the existing remote's name,\n    run:\n    \n    git remote -v\n    \n\n 2. Remove Existing Remote: If necessary, let's say you're replacing origin, you\n    can remove it with:\n    \n    git remote remove origin\n    \n\n 3. Add New Remote: Add the new remote URL using its name:\n    \n    git remote add origin <new-remote-URL>\n    \n\n 4. Set the Push Location: If it's a new remote or if you've removed the\n    previous one, make sure to set the upstream branch:\n    \n    git push -u origin main\n    \n\n\nUSE CASES\n\n * Shifting to a Fork: Useful when you need to send pull requests to a fork\n   instead of the original repository.\n   \n   git remote set-url origin https://github.com/USERNAME/FORKED-PROJECT.git\n   \n\n * Updating the URL: If you've renamed your GitHub username or switched to HTTPS\n   secure access, you'd update the URL accordingly:\n   \n   git remote set-url origin https://github.com/USERNAME/REPOSITORY.git\n   \n\n\nBEST PRACTICES\n\n * HTTPS vs. SSH: For secure connections, use the SSH protocol. You might need\n   to update your remote URL, or switch authentication.\n\n * Favor Git Commands: Although it's possible to manually edit the .git/config\n   file, using Git commands is safer and more transparent.","index":36,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"38.\n\n\nHOW DO YOU SYNCHRONIZE YOUR LOCAL REPOSITORY WITH A REMOTE REPOSITORY?","answer":"To synchronize a local Git repository with its remote counterpart, you will\nprimarily use the git fetch and git merge\nor‘gitpull‘,whichisacombinationofthetwoor `git pull`, which is a combination of\nthe twoor‘gitpull‘,whichisacombinationofthetwo commands.\n\n\nSYNCHRONIZATION WORKFLOW\n\n 1. Fetch Updates: Fetch new changes from the remote repository. This does not\n    automatically integrate the changes into your local branch.\n    \n    * The fetch command here updates the remote-tracking branches, keeping them\n      in sync with the state of the remote repository. It essentially points to\n      the latest commit on the remote branch. This helps in identifying the\n      diverged branches.\n    \n    git fetch\n    \n\n 2. Review Changes: Take this moment to review the changes before merging them.\n\n 3. Merge Changes: Combine the fetched changes with your current branch. You can\n    either use the separate fetch and merge steps or use a single git pull\n    command, which is a shorthand for both these operations.\n    \n    * Fetch and Merge Separately:\n    \n    git merge origin/<branch-name>\n    \n    \n    * Or, Use One Command:\n    \n    git pull\n    \n\n 4. Verify History: After the merge, review the commit history using git log to\n    ensure the merge incorporated the expected changes.\n\n\nKEY COMMANDS\n\n * Fetch: This fetches the latest changes from the remote, including new\n   branches and deleting branches that may have been removed remotely.\n   \n   git fetch\n   \n\n * Merge: Use this command to integrate the fetched changes into the current\n   branch. For a cleaner and more explicit history, especially in collaborative\n   environments, you might sometimes prefer not using git pull and instead fetch\n   and merge separately.\n   \n   git merge origin/<branch-name>\n   \n\n\nBEST PRACTICE TIP\n\nAvoid Direct Merges into Master: For repositories with a central authoritative\nmaster branch, like in a corporate context, consider setting up protected\nbranches. The typical workflow for such setups does not involve direct merges\ninto the master branch. Instead, developers create separate feature branches,\npush changes to the remote, and then raise pull requests or merge requests.\nThese requests undergo code review, testing, and other checks before being\nmerged into master. It's a proactive approach that helps ensure the quality and\nintegrity of the master branch.","index":37,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"39.\n\n\nHOW DO YOU CLEAN UP UNUSED BRANCHES IN YOUR LOCAL AND REMOTE REPOSITORY?","answer":"Maintaining a clean and organized Git repository is essential for efficient\ncollaboration. One important housekeeping task is to periodically remove\nobsolete branches, saving storage and reducing clutter.\n\nYou can employ these basic and advanced commands to perform branch management in\nboth local and remote repositories:\n\n 1. Local Branch Deletion\n    \n    * Basic: Remove a local branch after it has been merged into the main (or\n      another) branch.\n      \n      git branch -d branchName\n      \n    \n    * Force Delete: Removes a branch regardless of its merge status.\n      \n      git branch -D branchName\n      \n\n 2. Remote Branch Deletion\n    \n    * Basic: Deletes a remote branch and propagates the change to the shared\n      repository.\n      \n      git push origin --delete branchName\n      \n    \n    * Concise: A shorter form of the basic command.\n      \n      git push origin :branchName\n      \n\n 3. Housekeeping Tip: Remove Merged Branches Regularly\n    \n    Task you and your team run it during work\n    \n    * Inform: Let the team know that you intend to clear merged branches.\n    * Scan for merges: Only remove branches that have been merged into the main\n      branch.\n    * Run Periodically: Schedule this task as part of your workflow, for\n      example, each time you merge to the main branch.\n    * Keep PR Guidelines: For branches associated with Pull Requests, follow the\n      guidelines for merge and cleanup.\n\n 4. Advanced: Use Automation and Git Hooks\n    \n    * Custom Git Hooks: Configure Git to run auto-cleanup commands based on your\n      criteria.\n    * Automated Tools: Utilize external tools or Git extensions designed to\n      handle branch cleanup.\n\n 5. Respect Multi-Developer Environments\n    \n    * Work Segregation: When working in multiple environments (like Dev, Test,\n      and Prod), keep track of corresponding branches and remove them\n      appropriately when the work is done. This task often falls on the team\n      lead or designated individuals who oversee environment maintenance.\n\n 6. Scrutinize Before Deletion\n    \n    * Backup or Safety Repo: Consult with your team and validate the need for\n      branch deletion, especially if you're unsure about their purpose.\n    * Reliable Backup: Keep a reliable backup or safety repository strategy\n      before aggressive branch cleanups.\n\nRegular and thoughtful branch management boosts your repository's tidiness and\nhelps your team focus better.","index":38,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"40.\n\n\nDESCRIBE THE STEPS TO RESOLVE A MERGE CONFLICT IN GIT.","answer":"Resolving merge conflicts in Git involves selecting the desired changes from the\nconflicting branches and finalizing the merge.\n\n\nCONFLICT IDENTIFICATION\n\nA conflict arises when Git cannot automatically merge changes from multiple\nbranches. Each file with a conflict is marked with the <<<<<<< (HEAD), =======,\nand >>>>>>> (incoming commit) delimiters.\n\n<<<<<<<<< HEAD\nLocal branch changes\n=========\nIncoming commit changes\n>>>>>>>>> branch-name\n\n\n\nRESOLVING CONFLICTS LOCALLY\n\n 1. Locate Files with Conflicts:\n    \n    * Use Git commands, or look for the conflict markers in the code.\n\n 2. Open Each Conflicted File:\n    \n    * Locate & Remove conflict markers and undesired content.\n    * Choose between the branch (HEAD) and the incoming commit, or perform a\n      manual merge.\n\n\nWAYS TO RESOLVE CONFLICTS\n\n * Accept Incoming: Keep the version from the incoming branch, discarding the\n   changes made on the local branch.\n   \n   <Keep This>\n   \n\n * Accept Local/HEAD: Keep the version from the local branch (usually HEAD),\n   discarding the incoming changes.\n   \n   <<<Local/Head Changes>>>\n   \n\n * Manual Merge: Modify the content to keep specific changes from both branches.\n   \n   <<<Combine Desired parts>>>\n   \n\n\nCONFLICT-FREE FILE\n\nAfter resolving all conflicts in the file, remove any remaining conflict markers\nto indicate the merge is complete.\n\nThe resolved file then must be staged using:\n\ngit add <file>\n\n\n\nVERIFICATION\n\n * Perform a dry run of the merge to flag any potential issues.\n   \n   git merge --no-commit --no-ff <branch-name>\n   \n\n * If no problems are reported, commit the merge.\n   \n   git commit -m \"Merged <branch-name>\"\n   \n\n * Alternatively, you can abort the merge to revert back to the pre-merge state.\n   \n   git merge --abort\n   \n\n\nBEST PRACTICES\n\n * Frequent Commits: Make small, incremental changes and commit frequently to\n   minimize the risk of conflicts.\n * Clear Commit Messages: This can help future efforts.\n\n\nDON'T FORGET\n\nAfter resolving conflicts:\n\n 1. # git status:\n    \n    * Verify modifications are staged as expected.\n\n 2. # git diff --staged:\n    \n    * Check staged changes before committing.\n\n 3. # git commit:\n    \n    * Confirm modifications are committed successfully.\n\n\nRESOLUTION EXAMPLE\n\nHere is the federation of instructions:\n\n1. IDENTIFY CONFLICTS:\n\nWhen attempting to merge two branches, you receive a notification of the\nconflict or observe an error message.\n\n2. OPEN FILES WITH CONFLICTS:\n\nLocate the conflicted files using a command-line tool or text editor.\n\n3. RESOLVE WITH DESIRED CHANGES:\n\n * Accept Incoming Changes: Remove conflict markers, keeping the content from\n   the incoming commit, and then stage and commit.\n\n * Accept Local/HEAD Changes: Remove conflict markers, keeping the content from\n   the local branch (HEAD or current branch), and then stage and commit.\n\n * Perform a Manual Merge: Customize the content to integrate specific changes\n   from both branches. Then, remove conflict markers, stage, and commit.\n\nUse the following Git command to stage the resolved file:\n\ngit add <file>\n","index":39,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"41.\n\n\nWHAT IS GIT STASH USED FOR?","answer":"`git stash` is a useful command for temporarily shelving local changes and\nreverting to a clean working directory. This is particularly handy when you need\nto switch branches for a quick fix or to test something.\n\n\nKEY COMPONENTS\n\n * Stash List: Tracks saved stashes, enabling you to recover them later.\n * Stash Entry: Comprises both staged and unstaged changes, along with new\n   untracked files.\n\n\nGIT STATUS AND GIT DIFF\n\ngit status is the go-to command to check the current state of your working\ndirectory, staging area, and commits. On the other hand, git diff is useful for\ninspecting the specific content of what is staged and what is not.\n\nLet's see how git stash impacts these two commands.\n\nGIT STATUS\n\n * Before Stash: Your status might indicate modified or untracked files.\n * After Stash: The status is clean - it resembles a freshly checked-out branch\n   with no local modifications.\n\nGIT DIFF\n\n 1. Staged Changes: Stashing moves these changes to the stash entry, leaving\n    staging area and index clean.\n 2. Unstaged Changes: These are also stashed, ensuring that the entire working\n    directory is reverted before the 'stash apply'.\n\n\nBEST PRACTICES\n\n * Regular Checks: Commit often and only use git stash for transient changes or\n   tasks.\n * Purposeful Application: Stashes should have a clear objective and a\n   soon-to-be expected recovery point.\n * Temporary Nature: Avoid using stashes as a permanent storage solution. If\n   your changes are substantial or long-term, consider creating a WIP (Work in\n   Progress) commit instead.\n\n\nWHEN TO STASH\n\n * Instant Stash: When you need an immediate clean slate but your workspace\n   isn't ready for a commit or probably holds unfinished work.\n * Quick Branching: For effortlessly jumping between branches; especially useful\n   when you're in the middle of something and a prompt action on another branch\n   is required.\n\n\nSTASH LIFECYCLE\n\n 1. Creation: Stashing transforms your working directory into a blank slate.\n 2. Application: You can reapply your stash at any time.\n 3. Removal: Stashes can be either reapplied or removed. Removing a stash will\n    result in the loss of all changes from that stash entry.\n\n\nLIMITATIONS AND CONSIDERATIONS\n\n * Stale Stashes: As pull requests and merges advance, some stashed changes\n   might not be compatible with your latest branch contents. Be vigilant, and if\n   you suspect potential conflicts after applying a stash, consider reconciling\n   them immediately.\n\n * Parallel Stashing: It's absolutely possible to have multiple stashes active\n   concurrently. However, avoid excessive stashing as it could lead to a messy,\n   error-prone recovery process.\n\n\nTERMINOLOGIES: INDEX VS. STASH\n\n * Index: Tracks changes you've staged to be committed.\n * Staging Area: A region where you compile changes before committing.\n\nWhile the index reflects staged changes that are yet to be committed, the stash\nencompasses a broader spectrum of modifications, featuring both staged and\nunstaged alterations, ensuring nothing gets lost in the process of stashing or\nrecovering.","index":40,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"42.\n\n\nHOW DO YOU VIEW STASHED CHANGES IN GIT?","answer":"Stashing in Git is a way to keep a clean working directory while working on\nanother task or context. When you make a stash, Git resets the modifications in\nyour working directory and staging area but keeps the data accessible should you\nneed to re-apply it later.\n\n\nVISUALIZING STASH STACK\n\nYou can visualize the stash stack using the following command:\n\ngit stash list\n\n\nThe output shows a listing of all stashes in LIFO (Last In, First Out) order,\nwith the most recent stash at the top.\n\n\nSTASH LIST EXAMPLE\n\nstash@{0}: WIP on feature/foo: 9c1eb41 Added new feature\nstash@{1}: On master: 5e6e8be Fixed critical bug\n\n\nEach entry gives a unique stash reference (stash@{n}), a reference to the commit\nthat was in progress when the stash was created, and a message Git internally\nderives from the associated commit message.\n\n\nSTASH METADATA\n\nThe reference names that appear in the stash list are meant for temporary or\none-time use and are not intended for long-term reference. They may change over\ntime, and while they can be used in some contexts, it's not recommended to\ndepend on them for long-term operations.\n\nInstead of relying on the reference names like stash@{0}, you might consider\nusing the explicit git stash commands for more robust navigation and management\nof stashed changes. For example:\n\n * Applying the most recent stash: git stash apply or git stash pop\n * Applying or popping a specific stash: git stash apply stash@{2} or git stash\n   pop stash@{3}\n * Dropping a specific stash: git stash drop stash@{1}","index":41,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"43.\n\n\nCAN YOU APPLY A STASH WITHOUT REMOVING IT FROM THE STASH LIST?","answer":"You can definitely apply specific changes from a stash without removing it from\nthe stash list. Let's explore how you can achieve that using Git stash apply and\nrelated commands.\n\n\nMETHODS TO APPLY STASH WITHOUT REMOVING\n\nMETHOD 1: USING SPECIFIC STASH REFERENCES\n\nGit Version Control support stack-wise behavior. If you want to apply the\nchanges from the second-to-last stash, while keeping all others intact, you can\ndo so because the most recent stash is at the top of the stack.\n\ngit stash apply stash@{1}\n\n\nMETHOD 2: USING --INDEX OR --QUIET\n\n * You can apply the latest changes to both the working directory and the index\n   like so:\n   \n   git stash apply --index\n   \n   \n   or shorten it to:\n   \n   git stash apply -g\n   \n\n * To apply the changes silently, without displaying results, you can use:\n   \n   git stash apply --quiet\n   \n\nPRACTICAL EXAMPLE\n\nYou want to apply the changes from the sixth stash, but you only want to apply\nchanges that are staged. Here's the specific command you'll use:\n\ngit stash apply stash@{5} --index\n","index":42,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"44.\n\n\nWHAT DOES THE GIT CLEAN COMMAND DO?","answer":"git clean removes untracked files and directories from your working tree.\n\n\nKEY REASONS TO USE GIT CLEAN\n\n * Efficient Cleanup: If you want to ensure you have a pristine working\n   directory with no untracked files or directories, git clean is your tool.\n\n * Selective Cleanup: You can use options to be more selective, like preserving\n   files with certain attributes or in specific directories.\n\n\nWHY USE GIT CLEAN?\n\nGit's staging area isn't involved in untracked files. Although git add . might\nadd some of these files to the next commit, it doesn't affect existing untracked\nfiles. This behavior offers both flexibility and risk, especially when it comes\nto test files and temporary scripts that could clutter your working tree over\ntime.\n\n\nWARNING AND PRECAUTIONS\n\n * Lost Work: Git does not store untracked files permanently. Once you execute\n   git clean, these files are gone. Be thorough in your assessment before\n   running this command.\n\n * Upstream Effects: If you're on a subject branch and execute git clean, and\n   someone else merged a file with the same name just before, you could be\n   removing his work!\n\n\nBEST PRACTICES\n\n * Check Status First: Always run git status to see what files would be removed\n   using git clean.\n * Safety First: Start by using -n for a dry run. That shows you what would be\n   removed without taking action.\n * Selective Cleaning: Use -i or -n to select files/directories interactively or\n   by pattern. Alternatively, use -X to remove only ignored files.\n\n\nADDITIONAL TIPS\n\n * To remove untracked files alongside directories, use the -d option.\n * To remove ignored files as well, use -x.\n * If you want a more comprehensive dry run, use -n -d or -n -d -x.\n\n\nWHEN TO USE DRY RUN\n\nA dry run (indicated by -n or --dry-run) is a powerful initial step that lets\nyou see what would happen without the actual deletions taking effect. This\nsafety check can prevent irreversible data loss and give you peace of mind\nbefore proceeding with the clean-up.\n\nOnce you're satisfied with the dry run and certain you don't need the untracked\nfiles, you can run the command without -n to perform the actual clean-up.\n\n\nSYNTAX FOR GIT CLEAN\n\ngit clean [-f | -n | -i] [-e] [-X] [-d] [-q] [-x] [-s] [--] [path…]\n\n\nOPTIONS\n\n * -f: Force delete (use with caution!).\n * -n: Dry run.\n * -i: Interactive mode for selective deletion.\n * -e: Exclude files using a file.\n * -X: Remove ignored files.\n * -d: Remove directories.\n * -q: Quiet mode.\n * -x: Remove both untracked files and directories.","index":43,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"45.\n\n\nHOW DO YOU REMOVE A FILE FROM THE WORKING DIRECTORY WITHOUT DELETING IT FROM THE\nREPOSITORY?","answer":"*.gitignore and git rm\n\nIf you already have a file in your repository and you suddenly decide you no\nlonger want to track changes to it, the correct course of action is a bit\ndifferent than just deleting it. Instead, you should utilize the .gitignore file\nand the git rm command.\n\nThe .gitignore file primarily tells Git what files to ignore, but sometimes you\nmay need to remove a file from the repository without deleting it from your\nlocal directory.\n\n 1. Add to .gitignore or Remove Tracking: By adding the file name to .gitignore,\n    you can remove it from future commits. If the file is already being tracked\n    by Git, you'll also need to run git rm to remove it from the repository.\n\n 2. Remove Tracking Only: Execute the following command:\n    \n    git rm --cached <file>\n    \n    \n    This will remove the file from the repo, but keep a local copy.\n\n 3. Be Mindful of Ownership: Once the file is removed from the repository, it's\n    crucial to notify any collaborators not to remove the file locally,\n    especially if they haven't made the same change.\n\nIf the files are already committed, you can delete them from the remote\nrepository with git rm <file> and recommit, making sure to identify any shared\nfiles and communicate changes to the team.","index":44,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"46.\n\n\nHOW DO YOU VIEW THE COMMIT HISTORY IN GIT?","answer":"Git provides several commit-viewing mechanisms ranging from simple to detailed,\ndepending on your needs.\n\n\nCOMMIT-VIEWING MECHANISMS\n\n 1. Basic Log: To see an abbreviated list of commits, along with their SHA\n    (Secure Hash Algorithm) hashes and commit messages.\n    \n    git log --oneline\n    \n\n 2. Commit Details: To view the full commit history and more detailed\n    information for each commit.\n    \n    git log\n    \n\n 3. Graphical Tools: Git GUI and other graphical interfaces provide an\n    interactive way to browse commit history.\n\n 4. Interactive Rebase Tool: Offers a visual way to interact with commits during\n    a merge or rebase operation. It opens the commits in a text editor, allowing\n    for modification before integrating them.\n\n 5. Temporary History: Commands like git cherry-pick bring specific commits\n    temporarily into the front, providing an isolated view.\n\n 6. Bisect Tool: Helps locate the source of bugs by taking you through\n    historical commits, prompting for input on their validity.\n\n 7. Stash Stack: The stash area, with commands like git stash list, allows for\n    managing a stack of temporarily stashed changes.\n\nFor a more comprehensive ovewview of the commit history in Git, please see the\nvideo: [How to view the commit]?","index":45,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"47.\n\n\nEXPLAIN HOW TO FIND A COMMIT BY A SPECIFIC AUTHOR IN GIT.","answer":"Version control systems like Git enable precise tracking of authors'\ncontributions.\n\nTo find commits associated with a specific author or committer:\n\n 1. Access the Log: Use the git log command, combined with relevant options and\n    filtering techniques.\n\n 2. Identify Authors: Without filtering options, the log command might display\n    multiple authors and their associated commits.\n\n\nLOCATING BY EMAIL ID OR NAME\n\nYou can further refine your search by using the following filtering options:\n\n * '--author': Filters commits based on the specified author name.\n * '--author-email': Filters commits based on the specified email.\n\nThis command illustrates:\n\ngit log --author=\"John Doe\"  # Filters by name\ngit log --author=\"johndoe@example.com\"  # Filters by email\n\n\n\nUSING THE COMMITS OF A SPECIFIC AUTHOR\n\nIf you want to find all commits from a particular author, you can use the\n'--committer' option in combination with your set-up email address.\n\nHere's an example:\n\ngit log --committer=\"johndoe@example.com\"  # Filters by comitter's email address\n\n\n\nGLOBAL CONFIGURATION FOR GIT\n\nTo ensure you're associating commits with the right user, set your global Git\nconfiguration:\n\n * 'git config --global user.name'\n * 'git config --global user.email'\n\nThis sets the default user name and email for all repositories on your system.\n\n\nVERIFYING GIT CONFIGURATION\n\nYou can check your current Git configuration using:\n\ngit config --get user.name\ngit config --get user.email\n\n\nThis way, you can ensure that your commits are attributed to the correct\nauthors.\n\n\nPERSISTENCE\n\nFor ongoing use, remember to save changes using:\n\ngit config --global user.name \"Your Name\"\ngit config --global user.email \"youremail@domain.com\"\n","index":46,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"48.\n\n\nHOW DO YOU VIEW THE CHANGES INTRODUCED IN A COMMIT?","answer":"Commits in Git are snapshots of your project at specific points, and they\nprovide a wealth of information about the changes made from the previous state.\n\nYou can view changes introduced by these commits in several ways, including\ncontextual differences, specific deltas, and detailed prior states.\n\n\nTOOLS FOR VIEWING COMMIT CHANGES\n\n 1. git show: This command displays the textual and visual differences of each\n    file that changed in the specific commit. It's equivalent to running git log\n    -p <sha> for that commit.\n    \n    git show <commit-hash>\n    \n\n 2. git log -p: This command shows the full patch text after the commit\n    metadata. You can further limit it to a specific file.\n    \n    git log -p <filename>\n    \n\n 3. SourceTree: A visual Git tool that provides a more comprehensive view of the\n    changes, including visual file comparison.\n\n 4. GitHub Web Interface: Offers a user-friendly diff tool when you view commit\n    history.\n\n\nBEST PRACTICES\n\nWhen reviewing a commit, consider the following:\n\n * Commit Size: Are the changes granular and logically contained within a single\n   feature or fix?\n * Code Clarity: Does the commit adhere to well-named functions, clear variable\n   names, and appropriate comments?\n * Coherence: Are the changes coherent with the commit message and the wider\n   context of the project?\n * Standard Practices: Does the commit follow conventions and best practices of\n   the team or community?\n\n\nKEY TAKEAWAYS\n\n * Multiple tools and commands help review commits in Git.\n * Contextual and file-level changes can be examined to ensure code quality and\n   track the project's progress.","index":47,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"49.\n\n\nCAN YOU LIST THE FILES CHANGED IN A SPECIFIC COMMIT?","answer":"Certainly! You can use the git diff command to view differences in your working\ndirectory, staging area, and a specific commit.\n\n\nSTEPS TO VIEW COMMIT CHANGES\n\n 1. Obtain Commit ID: Get the unique identifier for the target commit, either by\n    looking at the commit history or using a tool like GitKraken.\n\n 2. Use git diff Command:\n    \n    * For the Working Directory and Staging Area:\n      \n      * git diff (without options) compares the working directory to the staging\n        area.\n      * git diff --staged or git diff --cached compares the staging area to the\n        repository.\n    \n    * For a Specific Commit:\n      \n      git diff <commit_ID>\n      \n    \n    Key Tip: To list file names only, add the --name-only option under any of\n    the above cases.\n\n\nPRACTICAL EXAMPLES\n\nHere are the commands to view differences as per the discussed methods.\n\nFULL WORKING DIRECTORY TO COMMIT\n\n * To compare the complete working directory to the files in the commit:\n   \n   git diff --name-only <commit_ID>\n   \n\nPARTIAL STAGING AREA TO COMMIT\n\n * In case you wish to examine changes only for the files in the staging area,\n   use the following command:\n   \n   git diff --name-only --cached <commit_ID>\n   \n\nCODE COMMIT OF A SPECIFIC FILE\n\n * When you are interested in changes linked to a particular file, execute the\n   command:\n   \n   git diff --name-only <commit_ID> <file_path>\n   \n\n\nDETAILED EXPLANATION\n\n * Comparing Areas: The git diff command without any parameters compares the\n   working directory with the staging area. To see changes between the staging\n   area and a specific commit, you add the --cached flag.\n\n * Output Specifications: The --name-only option specifies that the command\n   should focus on the names of the files changed, rather than displaying the\n   actual contents.","index":48,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"50.\n\n\nWHAT DOES THE GIT BLAME COMMAND DO?","answer":"The git blame command helps developers understand the history of a file in terms\nof contributions. It displays individual lines along with the relevant commit\nand author details.\n\n\nHOW IT WORKS\n\ngit blame examines every line in a file and provides information about the\ncommit responsible for its most recent change. This includes the commit SHA, the\nauthor of the change, the timestamp, and the line's content.\n\nThe command is especially useful for identifying when and by whom specific lines\nwere added or modified, providing granular insights.\n\nKeep in mind that file editing might involve complex commit histories, such as\nmerges or rebased branches, which can influence the accuracy and presentation of\nthe blame data.\n\n\nCOMMAND OPTIONS\n\n * -L<num1>,<num2>: Limits output to the specified line range.\n * -C (or --find-copies): Unifies similar lines and detects copied content\n   across the file's history.\n * -M (or --find-renames): Detects file sections that were renamed or moved in\n   the history.\n * -C -C or -M -M: Increases content detection threshold, useful for detecting\n   more copies or renames.\n * -p, --porcelain: Outputs in a more script-friendly format. Curtail\n   dye-status.\n\n\nBEST PRACTICES\n\n * Contextualize Findings: Upon using git blame, consider reviewing the commit\n   referred to for added context.\n * Use Wisely: The command can become less effective when looking at older or\n   frequently changed files. It's also not well-suited for providing an overview\n   of a file's history.\n * Respect Privacy: While the blame feature is extensive, it's important for\n   team dynamics that its use remains judicious and professional.","index":49,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"51.\n\n\nWHAT ARE GIT TAGS AND HOW ARE THEY DIFFERENT FROM BRANCHES?","answer":"Tags in Git are used to mark specific points in time within the history of a\nrepository. They are commonly used to designate release versions such as v1.0,\nv2.0, etc.\n\n\nKEY DISTINCTIONS\n\nMUTATION\n\n * Branches: Dynamic and are intended for ongoing, usually feature-based\n   development. Branches are frequently updated with new commits.\n * Tags: Immutable and represent snapshots at a specific point in time. They\n   don't move or change with subsequent commits.\n\nSTORAGE\n\n * Branches: They consist of pointers (references) to specific commits and can\n   be compared to movable labels.\n * Tags: These are specific to a commit and serve as stable markers, akin to\n   etching a commitment in stone.\n\n\nTAG TYPES\n\n * Lightweight: Simply references a specific commit. Not recommended for\n   official releases as they lack metadata.\n * Annotated: Stores additional information such as the tagger, date, and a\n   tagging message. Preferred for formal releases.\n\n\nTAGGING COMMANDS\n\nANNOTATED TAG\n\nUse git tag -a <tag_name> -m \"tag message\" to create an annotated tag. It will\nprompt for a message.\n\nFor an existing commit: git tag -a <tag_name> <commit_hash> -m \"tag message\"\n\nLIGHTWEIGHT TAG\n\nTo create a lightweight tag, use git tag <tag_name>. This will tag the most\nrecent commit.\n\nFrom a specific commit: git tag <tag_name> <commit_hash>\n\n\nWORKING WITH TAGS\n\nLOCAL OPERATIONS\n\n * Pushing Tags: Execute git push --tags to push all tags to the remote\n   repository.\n\nREMOTE OPERATIONS\n\n * Pulling Tags: Latest tags can be acquired using git fetch --tags. It is\n   conventional to fetch tags before establishing unique local tracking.\n\nTAGGING A COMMIT AFTER-THE-FACT\n\nIf you're looking to tag a commit that you didn't previously tag, you can do so\nas follows:\n\ngit tag -a v1.2 9fceb02 -m \"Tagging v1.2\"\ngit push --tags\n\n\n\nVIEWING TAGS\n\nVERIFICATION\n\nList all tags with git tag and display information about a certain tag with git\nshow <tag_name>.\n\nREMOTE TAGS\n\nIn shared repositories, remote tags might be distinct from those observed\nlocally. Use git tag -l after a fetch --tags to ensure local consistency.\n\n\nTAG BEST PRACTICES\n\n * Consistent Naming: Choose a naming convention and adhere to it, e.g.,\n   semantic versioning.\n * Clear Messages: Annotated tags should have explicit messages giving insights\n   into the tagged commit.\n * Version Control: Tags should be used in association with a distinct commit or\n   commit range.\n\n\nIMPORTANCE IN COLLABORATION\n\n * Communication Aid: Tags help in communicating about specific commits or\n   releases.\n\n * Semantic Versioning Compliance: For libraries, frameworks, and other\n   components, tags are used to regulate versions following semantic versioning.\n   \n   Follow this strategy:\n   \n   * Use major versions vX.0.0 for substantial, possibly disruptive changes.\n   * Increment the minor version v1.X.0 for additive modifications.\n   * Reserve the patch version v1.0.X for small updates and bug fixes that are\n     compatible with previous releases.","index":50,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"52.\n\n\nHOW DO YOU CREATE, DELETE, AND PUSH TAGS?","answer":"While primarily designed for versioning commits, Git also provides means to\nversion notable points in history through tags. Let's look into different tag\ntypes:\n\n\nTYPES OF GIT TAGS\n\n 1. Lightweight Tags: These are essentially pointers to specific commits and do\n    not contain any metadata such as tagger and date. They are created with a\n    single command.\n\n 2. Annotated Tags: These are full objects in the Git database and are\n    checksummed. They contain the tagger name, email, date, and tagging message.\n    This style of tagging is more explicit and is often recommended when\n    releasing software. To see the differences between these two types of tags\n    and the tag data:\n\n\nCOMMANDS FOR TAG OPERATIONS\n\n 1. Create a Tag: The command will differ slightly based on the type of tag you\n    want to create.\n    \n    * Lightweight: git tag <tag-name>\n    * Annotated: git tag -a <tag-name> -m \"Tagging version X.Y.Z\"\n\n 2. Delete a Tag:\n    \n    git tag -d <tag-name>  # Local deletion\n    git push origin --delete <tag-name>  # Remove from remote as well\n    \n\n 3. Push Tags to Remote:\n    \n    git push origin <tag-name>  # To push a specific tag\n    git push origin --tags  # To push all tags\n    \n\n 4. Fetching Tags:\n    \n    You can use git fetch --tags to retrieve all tags from a remote repository.\n\n 5. View Tag Information:\n    \n    * To see all tags: git tag\n    * To look at details of a specific tag, use git show <tag-name>\n\n\nPRACTICAL EXAMPLE\n\nHere is the git code:\n\n# Create a tag\ngit tag -a v1.0 -m \"Initial release version 1.0\"\n\n# Delete a local tag\ngit tag -d mytagname\n\n# Push the tag to the remote repository\ngit push origin --tags\n","index":51,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"53.\n\n\nWHAT IS SEMANTIC VERSIONING IN THE CONTEXT OF GIT TAGGING?","answer":"Semantic Versioning (SemVer) is a versioning convention that standardizes\nreleases for software libraries. When applied to Git tagging, it provides a\nclear understanding of a version's changes based on three identifiers: major,\nminor, and patch.\n\n\nSEMVER IDENTIFIERS\n\nThe three numeric identifiers signify:\n\n * Major: Radically altered software, particularly its public interfaces.\n * Minor: Introduces new, backward-compatible features.\n * Patch: Resolves specific and backward-compatible issues.\n\n\nGIT TAGGING IMPLEMENTATION FOR SEMVER\n\nHere is the Python code:\n\nimport git\n\nrepo = git.Repo('.')\nlatest_tag = repo.tags[-1]\nprint(f\"Latest Tag: {latest_tag.name}\")\n\n# Use parse function if using a library like `semantic_version`.\nmajor, minor, patch = map(int, latest_tag.name.lstrip('v').split('.'))\nprint(f\"Next Version: {major}.{minor}.{patch + 1} (Patch)\")\n\n# To tag next release:\n# repo.create_tag(f'v{major}.{minor}.{patch + 1}')\n\n\n\nCOMMITS AND VERSION INCREMENTS\n\nDepending on what's being committed, the version needs to be updated\naccordingly:\n\n * Major: New features breaching backward compatibility.\n * Minor: Introduces additional features without breaking the existing ones.\n * Patch: Bug fixes or changes that maintain backward compatibility.\n\n\nAUTOMATED VERSION CONTROL\n\nVarious tools automate version control:\n\n * CI/CD Pipelines: Triggered by certain changes.\n * File Trackers: Observe code files and auto-update the version based on\n   changes.\n * Library Integrations: Management systems like npm and pip offer versioning\n   automation.","index":52,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"54.\n\n\nHOW WOULD YOU CHECKOUT TO A SPECIFIC TAG?","answer":"When you want to check out to a specific tag in Git, you use the git checkout\ncommand.\n\n\nHOW TO CHECKOUT TO A TAG\n\nSelecting a Git tag for checkout can be done with a special flag.\n\nCOMMAND SYNTAX\n\ngit checkout tags-name\n\n\nEXAMPLE\n\ngit checkout v1.2\n","index":53,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"55.\n\n\nDESCRIBE HOW TO CREATE A RELEASE FROM A TAG.","answer":"One way to create a release from a tag in Git, is to utilize the GitHub web\ninterface.\n\n\nSTEPS TO CREATE A RELEASE FROM A TAG\n\n 1. Locate the Tag: Navigate to the \"Releases\" tab on GitHub's repository main\n    page to find an existing tag.\n\n 2. Draft a New Release: Click on the \"Create a new release\" button and,\n    optionally, select the tag you want to base the release upon.\n\n 3. Define Release Details\n    \n    * Tag Version: Ensure the tag you intend to use is selected.\n    * Release Title: Add a descriptive title.\n    * Release Description: Provide release notes and details about changes.\n\n 4. Publish the Release: Save the draft as a release without publishing, or\n    directly publish the release.\n\n\nCOMMAND-LINE APPROACH\n\nTo expedite the process on your local machine, you can use the git command-line\ninterface and a tool like Hub to interface with GitHub.\n\nHere is the implementation of the command-line approach:\n\nStep 1: Install GitHub official CLI tool gh for interacting with GitHub from the\ncommand line.\n\nFor Mac, use Homebrew:\n\nbrew install gh\n\n\nFor Windows:\nInstall the latest version from their assets of the GitHub CLI on GitHub\nReleases Page [https://github.com/cli/cli/releases].\n\nFor Linux, you can follow the official instructions or use snap or apt:\n\nsnap install gh\n\n\nor\n\nsudo apt-key adv --keyserver keyserver.ubuntu.com --recv-key C99B11DEB97541F0\nsudo apt-add-repository https://cli.github.com/packages\nsudo apt update\nsudo apt install gh\n\n\nStep 2: Log in to your GitHub account from the command line.\n\ngh auth login\n\n\n\nCOMMANDS:\n\nUse gh commands as shown below to streamline the release process:\n\nCreate a Draft Release from a Tag:\n\ngh release create <tag_name> --draft\n\n\nUpdate Release Notes:\n\ngh release edit <tag_name>\n\n\nPublish the Release:\n\ngh release upload <tag_name> FILE\ngh release publish <tag_name>\n","index":54,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"56.\n\n\nWHAT IS A GIT SUBMODULE AND WHEN WOULD YOU USE ONE?","answer":"A Git submodule is a repository embedded within another Git repository. It\ntracks a specific commit but is semilink, so if the submodule directory is ahead\nor behind the parent repository, it's easy to miss the changes in the submodule.\n\n\nWHEN TO USE GIT SUBMODULES\n\n 1. Code Reusability: When leveraging common code across multiple projects,\n    submodules ensure consistency through shared codebases.\n\n 2. Maintenance: For dependencies being actively developed and managed,\n    submodules provide granular control over versions.\n\n 3. Isolating Concerns: In projects with different teams responsible for\n    distinct parts, submodules enable autonomy of development.\n\n 4. Version-Specific Dependencies: Submodules enable precise versioning of\n    dependencies, ensuring compatibility.\n\n 5. Granular, As-Needed Management: For projects requiring select parts or\n    dependencies from a larger codebase, submodules allow for selective\n    inclusion.\n\n 6. Third-Party Integrations: When integrating third-party libraries or tools\n    directly from a source code manager like GitHub, submodules offer\n    straightforward integration and version control.\n\n 7. Testing and Deployment Workflow Control: Submodules aid in managing specific\n    configurations tailored for testing and deployment workflows.","index":55,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"57.\n\n\nEXPLAIN THE PURPOSE OF A GIT HOOK.","answer":"Git hooks are customizable scripts that Git can run at specified points in the\nrepository's lifecycle. Here are some of the key benefits and use-cases they\noffer.\n\n\nKEY PURPOSES\n\n * Validating Code: Enforce a consistent style, perform static analysis, or run\n   tests before commits or pushes.\n * Preventing Unwanted Code: Reject commits that contain secrets, large files,\n   or other undesired content.\n * Enforcing Standards: Ensure that code adheres to specific criteria before\n   being accepted into the repository.\n * Automating Tasks: Execute actions such as installing dependencies, compiling\n   code, or updating documentation upon specific events.\n * Notifying External Systems: For example, triggering builds in a continuous\n   integration pipeline.\n\n\nCUSTOMIZATION LEVELS\n\n * Project-Specific: Hooks tailored to the requirements and specific workflows\n   of a particular project.\n * Global (Repository-Independent): Hooks used uniformly across all projects on\n   a given system. This is effective for setting common standards, like ensuring\n   all files adhere to a certain format. However, users must be mindful since\n   global hooks impact all repositories.\n\n\nTRIGGER POINTS\n\n * Client-Side\n   \n   * Pre-Command: Triggered before user actions like commit, merge, or rebase.\n   * Post-Command: Follows user actions; useful for notifications or launching\n     external processes.\n   * Reference-Update: Fires when references (e.g., branches or tags) are added\n     or removed, providing a veto option.\n\n * Server-Side\n   \n   * Receive-Pack: Active on the remote server after a push occurs. Can check\n     and reject incoming changes.\n\n\nVALIDATIONS AT DIFFERENT STAGES\n\n * Pre-Commit: Verify the contents of the forthcoming commit.\n * Pre-Push: Inspect or decline the local work intended for pushing or serve as\n   a notification mechanism.\n * Post-Receive: Useful on the server-side after a push, assessing the provided\n   changes.\n\n\nCONFIRMATION AND COMMUNICATION\n\nHooks enable visual and terminal notifications. Although they don't emanate from\nGit, one can build them into the scripting. Client-side hooks can concretely\nhalt an operation if not satisfied.\n\n\nKNOWN CONSTRAINTS\n\n * Subject to Users and Git Configuration: Knowledgeable developers can bypass\n   hooks.\n * Distribution Limitations: Hooks are not propagated during cloning,\n   necessitating additional setup.\n\n\nPRACTICAL IMPLEMENTATIONS\n\n 1. Coding Standards: Pre-Commit hook to validate code against a style guide and\n    Reject commits that don't comply.\n\n 2. Testing: Pre-Commit or Pre-Push hooks to run unit tests. The push can be\n    prevented if the tests don't pass.\n\n 3. Build Automation: If a repository allows direct deployments to a server, a\n    Post-Receive hook can trigger a build or deployment.\n\n 4. Collaborative Workflows: A Pre-Push hook can ensure that conflicts don't\n    exist before pushing, minimizing the need for excessive merges.","index":56,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"58.\n\n\nHOW DO YOU PERFORM A SQUASH COMMIT IN GIT?","answer":"Squashing multiple commits on a branch is a great way to clean up your commit\nhistory before merging it into the main branch. This can reduce clutter and\npresent a more readable narrative of the changes made.\n\n\nSQUASH COMMITS WORKFLOW\n\n 1. Select Where to Start Squashing: Identify the commit prior to the changes\n    you want to squash. This is often the commit where you diverged from the\n    main branch. It's important to list the exact number of commits to squash.\n\n 2. Interactively Rebase: Perform an interactive rebase using the git rebase\n    command and specify the number of commits to squash.\n\n 3. Resolve Conflicts and Describe Changes: If there are any conflicts during\n    the rebase, Git lets you resolve them. When you squash commits, you're asked\n    to provide a new commit message that describes the actions included in the\n    squashed commits.\n\n 4. Finalize Rebase: After resolving conflicts and updating the commit message,\n    complete the rebase and push the changes.\n\n\nSTEP-BY-STEP INSTRUCTIONS\n\n 1. Identify the Starting Point: In this example, we want to squash the last 3\n    commits on our branch. The branch looks something like this:\n    \n    A - B - C - D         // HEAD and branch-to-squash-commits\n    \n    \n    Here, commit D is the most recent one. We want to go back to commit B since\n    we want to squash commits C, D, and E.\n\n 2. Begin Interactive Rebase: Initiate an interactive rebase using the following\n    command inside your branch:\n    \n    git rebase -i HEAD~3\n    \n    \n    To squash the last three commits, we choose HEAD~3. The list of commits then\n    appears in our preferred text editor:\n    \n    pick c541046 Add feature C\n    pick 51d4c80 Add feature D\n    pick ead2bd1 Add feature E\n    \n    \n    Replace pick with squash (s) or simply s for the commits you want to squash.\n    After making the changes:\n    \n    pick c541046 Add feature C\n    squash 51d4c80 Add feature D\n    squash ead2bd1 Add feature E\n    \n    \n    Save and close the file.\n\n 3. Modify the New Commit Message: The editor will prompt you to modify the\n    consolidated commit message which will summarize the squashed changes. Make\n    any necessary changes, save, and close the editor.\n\n 4. Complete the Rebase and Push Changes: Finish the rebase with:\n    \n    git rebase --continue\n    \n    \n    The changes are now on your branch, and you might need to force-push them to\n    the remote to update the branch with squashed commits:\n    \n    git push origin your-branch-name --force\n    \n    \n    Caution:\n    \n    Be extra cautious while using the --force flag, especially on shared or\n    public branches, as it rewrites the branch's history. Qed can result in data\n    loss if not used carefully.\n\n\nCODE EXAMPLE: SQUASHING WITH REBASE\n\nHere is the bash code:\n\n# Identify the starting commit (if we want to squash the last 3 commits)\ngit log --oneline -3  # To see the last 3 commits\n\n# Initiate interactive rebase to squash the last 3 commits\ngit rebase -i HEAD~3\n\n# Replace 'pick' with 'squash' for the commits to be squashed\n# Save and close the editor\n\n# Resolve any potential conflicts, modify the combined commit message, and continue the rebase\n\n# Finally, force-push the changes to the remote branch\ngit push origin your-branch-name --force\n\n\nReminder: Be mindful when force-pushing as it alters the branch's history.\n\n\nIN-DEPTH LOOK: INTERACTIVE REBASE AND AUTOSQUASH\n\nThe git rebase command offers a range of options for both simple and intricate\ncommit manipulations, empowering users to keep their commit history clear and\nfocused.\n\nCORE OPTIONS\n\n * -i or --interactive: Initiates an interactive rebase session.\n * HEAD~N or a commit hash: Specifies the base commit where you want to start\n   the rebase.\n\nADVANCED OPTIONS\n\n * --autosquash: Aids in automatic commit squashing while using the git rebase\n   command. To utilize autosquash, make sure that you have your 'todo' file set\n   up appropriately.\n\nINTERACTIVE REBASE ENTER MODE\n\nIn interactive rebase mode, the last n commits relative to HEAD are displayed,\nand actions are permitted on each of these commits. The common actions include:\npick, reword, edit, squash, and fixup, each serving a different purpose.\n\nThe commands can also be given in an abbreviated or inverse form. For instance,\nf or drop can replace fixup. If a commit is marked for a quick action, the\nassociated command can be omitted from the to-do list.\n\nCommands are parsed from top to bottom in the order they appear. Additionally,\nblank lines and lines that start with '#' are disregarded. To execute the rebase\nplan, save and quit the editor once the to-do list is in agreement with the\ndesired rebase actions.\n\n\nEXTRA TIPS FOR A CLEAN COMMIT TRAIL\n\nThematic grouping, logical ordering, and descriptive commit messages can make\nyour commits and pull requests more comprehensible. It's also beneficial to\ndelete outdated or extraneous commits before merging them.\n\n * Consider fragmenting your work into bite-sized, focused tasks.\n * Limit each commit to a single logical change.\n * Review your commit log regularly, using commands like git log --oneline.\n\n\nBEST PRACTICES FOR SQUASHING COMMITS\n\n * Coordinate Collaboratively: In shared repositories, harmonize with team\n   members or adhere to established conventions.\n * Prioritize Transparency: If privacy isn't a concern, communicate changes to\n   others who are working on the same branch.\n * Use Interactive Rebase Locally: Minimize utilizing force-pushes after a\n   rebase.\n\n\nSIMPLIFIED APPROACH: SQUASHING WITH AUTOSQUASH\n\n * To automate the process, prepend each initial commit message with squash! or\n   fixup!.\n * When initiating a rebase, use git rebase --interactive --autosquash to\n   directly consolidate these marked commits.\n\nWhile these practicalities can save time, they aren't without potential\ndrawbacks, and prudent use is advised.","index":57,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"59.\n\n\nWHAT IS A GIT BISECT AND HOW DO YOU USE IT?","answer":"Git bisect is a powerful tool that aids in identifying the exact commit where a\nbug or issue was introduced.\n\n\nBISECT WORKFLOW\n\n 1. Set Range: Initiate bisect with the known states - good (free from the\n    issue) and bad (issue present).\n\n 2. Test Commits: Bisect navigates your commit history, and you test each commit\n    for the presence of the issue. Based on the outcome, you mark the commit as\n    \"good\" or \"bad\".\n\n 3. Reach Root Cause: Continue this process of elimination until bisect\n    identifies the exact commit that introduced the issue.\n\n 4. Conclude and Reset: Once the problematic commit is identified, bisect is\n    stopped, and the system is reset to its initial state.\n\n 5. Analyze and Fix: With the problematic commit in hand, you can thoroughly\n    investigate it to understand what caused the issue and rectify it.\n\n\nPRACTICAL APPLICATION\n\nBisect offers a straightforward approach. After initializing the bisect\noperation, you can alternately instruct it with git bisect good or git bisect\nbad according to your test results, until the culprit commit is pinpointed.\n\nHere is the workflow for using git bisect.\n\n 1. Start Bisect:\n    \n    git bisect start HEAD <commit_id>\n    \n    \n    This command marks your current commit as \"bad\" and specifies a previous\n    commit or a known ancestor as \"good\".\n\n 2. Verify State and Tests:\n    \n    Ensure your project is in a desirable state and launch the testing mechanism\n    (it might be manual or automated)—depending on the nature of the issue.\n\n 3. Iterate:\n    \n    After each test, qualify the current commit as \"good\" or \"bad\". When using\n    automated tests, you might have a script to do this for you. For manual\n    inspection, commands are:\n    \n    * git bisect good: If the issue is absent.\n    * git bisect bad: If the issue is present.\n\n 4. Identify Culprit:\n    \n    Keep iterating the \"good\" and \"bad\" qualifications until the culprit commit\n    is identified.\n\n 5. Conclude:\n    \n    Once the problematic commit is isolated:\n    \n    git bisect reset  # To end the bisect session\n    ","index":58,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"60.\n\n\nHOW DO YOU MANUALLY RESOLVE A CONFLICT DURING A GIT MERGE?","answer":" * Merge Conflicts in Git arise when branches have diverged, typically due to\n   multiple developers modifying the same file, or changes occurring\n   independently.\n\n * To resolve a merge conflict, you must choose between the changes in the\n   conflicting files and denote the conflicts as resolved.\n\n\nSTEPS TO MANUALLY RESOLVE MERGE CONFLICTS\n\n 1. Identify Conflicted Files: Git notifies you about the files with conflicts.\n    You can use git status to check.\n\n 2. Open the Files: Open the conflicted files with a text editor. Look for\n    special markings that indicate the conflicting sections, such as <<<<<<<,\n    =======, and >>>>>>>. Each conflicting section is separated by =======.\n\n 3. Resolve the Conflicts: Manually edit the file to keep the desired changes\n    and remove the conflicting content. Remove the special markings as you\n    resolve each conflict.\n\n 4. Stage the Resolved Files: After resolving conflicts, stage the files with\n    git add.\n\n 5. Complete the Merge: To conclude the merge operation, use git merge\n    --continue or git commit to create a merge commit. If the resolution is to\n    abort the merge, use git merge --abort.\n\n 6. Review the Merge Commit: Inspect the merge commit with git show to ensure\n    the conflicts are resolved.\n\n 7. Push or Pull as Needed: Once the merge is committed, push changes to share\n    them with the remote repository or pull any changes from the remote.\n\n\nEXAMPLE USING CLI\n\nHere is the Git CLI:\n\n 1. Check Status:\n    \n    git status\n    \n    \n    This highlights the conflicting files.\n\n 2. Open in Text Editor:\n    \n    Use your preferred text editor to open the conflicted files.\n\n 3. Resolve Conflicts:\n    \n    Remove the undesired changes or adapt them to incorporate both branches as\n    necessary.\n\n 4. Stage Files:\n    \n    Once conflicts are resolved, stage the files:\n    \n    git add <filename>\n    \n\n 5. Commit or Conclude Merge:\n    \n    Create a merge commit to conclude the merge process:\n    \n    git commit\n    \n\n\nWHY WE SHOULD KEEP HISTORY CLEAN\n\nKeeping git history clean reduces complexities and potential errors. Start or\nrebase your active branches from the latest stable main branch (for example,\nmain, develop, or a release).","index":59,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"61.\n\n\nHOW DO YOU SET YOUR USERNAME AND EMAIL IN GIT?","answer":"Your Git username and email are associated with each commit. Manually set these\ndetails in the configuration file or use Git commands to streamline the process.\n\nThere are two distinct ways to accomplish this:\n\n 1. Global Configuration: Utilized for each repository on your system, this\n    setting is ideal for your primary GitHub profiles.\n\n 2. Project-Specific Configuration: Useful when different projects have distinct\n    contributors, you can employ your secondary GitHub profiles for specific\n    projects.\n\n\nGLOBAL CONFIGURATION\n\nUse the following commands to set your username and email globally:\n\ngit config --global user.name \"Your Name\"\ngit config --global user.email \"youremail@domain.com\"\n\n\n\nPROJECT-SPECIFIC CONFIGURATION\n\nNavigate to your project's root directory and activate project-specific settings\nwith these commands:\n\ngit config user.name \"Your Name\"\ngit config user.email \"youremail@domain.com\"\n\n\nVERIFY SETTINGS\n\nTo verify your updated credentials, ensure to run:\n\ngit config --global --get user.name\ngit config --global --get user.email\n\n\nand\n\ngit config --get user.name\ngit config --get user.email\n","index":60,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"62.\n\n\nWHAT IS THE SCOPE OF GIT CONFIGURATION FILES?","answer":"The scope of Git configuration files can be local to a repository, specific to a\nuser, or global across a user's projects.\n\n\nLOCAL SCOPE\n\n * Configuration File: .git/config\n\n * Visibility: Repository-specific\n\n * Purpose: Custom settings or user details specific to the repository\n   \n   It takes precedence over global and user configurations in the same\n   repository.\n\n\nUSER SCOPE\n\n * Configuration File: .git/config --global\n * Visibility: User Account-specific\n * Purpose: Personal settings for all repositories of a user\n\n\nSYSTEM SCOPE\n\n * Configuration File: /etc/gitconfig and /etc/git/config forLinuxsystemsfor\n   Linux systemsforLinuxsystems or C:\\ProgramData\\Git\\config onWindowson\n   WindowsonWindows\n * Visibility: System-wide\n * Purpose: Set options for users on the system\n\n\nNOTES\n\n * The configuration levels are hierarchical, with local taking precedence over\n   global, which, in turn, is preferred over system-wide settings.\n\n * Those settings can be managed through commands such as git config or directly\n   in the Git config files.","index":61,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"63.\n\n\nHOW CAN YOU CREATE ALIASES FOR GIT COMMANDS?","answer":"Git aliases streamline common and often complex commands, improving developer\nproductivity and workflow consistency.\n\nThese shortcuts are user-defined and can be as simple as a one-word command or\nas complex as a multi-step action. They're particularly beneficial for\naccomplishing repetitive or multi-step tasks.\n\n\nSETTING UP GIT ALIASES\n\nUSING GIT CLI\n\nGit aliases can be added via the terminal or command line interface using git\nconfig:\n\ngit config --global alias.st status\n\n\nGlobal vs Local Configuration:\n\n * Global: Applies across all repositories for the user.\n * Local: Only effective within the current repository.\n\nDIRECTLY MODIFYING CONFIG FILES\n\nAliases can also be set up by making manual changes to the Git configuration\nfiles:\n\n * Global Configuration Path: ~/.gitconfig\n * Local Configuration Path: <path-to-repository>/.git/config\n\nExample of Setting Up an Alias in the Configuration File:\n\n[alias]\n  co = checkout\n\n\n\nPRACTICAL EXAMPLES\n\nBASIC ALIASES\n\n 1. Checking Out the Master Branch:\n    \n    git config --global alias.master \"checkout master\"\n    \n    \n    After this, executing git master in the terminal will have the same effect\n    as git checkout master.\n\nADVANCED ALIASES\n\n 1. Visualize Git History:\n    \n    It combines git log with flags for a more streamlined view.\n    \n    In the config file:\n    \n    [alias]\n      hist = log --all --graph --decorate --oneline\n    \n    \n    This lets you invoke git hist to visualize project history.\n\n 2. Pushing Current Branch to a Remote:\n    \n    For the purpose of pushing the current branch to a specified remote and\n    setting that as the upstream:\n    \n    [alias]\n      publish = !git push -u origin HEAD\n    \n    \n    The ! signifies an inline command, and HEAD refers to the latest commit on\n    the current branch.\n\nCAVEATS OF ALIASES\n\n 1. Potential Conflicts:\n    \n    Aliases can risk interfering with system commands or other aliases. Make\n    sure to pick unique names.\n\n 2. Readability and Team Consistency:\n    \n    Team-based projects benefit most from defined, uniform alias conventions\n    that are easily understandable by all members.\n\n 3. Subcommands and Arity Limitations:\n    \n    Aliases are best suited for single commands and might not handle complex\n    input or multiple commands.","index":62,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"64.\n\n\nWHAT IS THE PURPOSE OF A .GITIGNORE FILE?","answer":"The .gitignore file is a critical tool in Git for managing project files. It's\nused to tell Git which files or patterns it should ignore so that they are not\ntracked or staged for commit. This is especially useful for files that are\nautomatically generated or contain sensitive data, such as log files or API\nkeys.\n\n\nWHY USE .GITIGNORE?\n\n * Maintaining Clean Repositories: By ignoring unnecessary files, repositories\n   stay focused on source and configuration files, avoiding clutter.\n\n * Privacy and Security: Storing sensitive data, like passwords or API keys, in\n   a Git repository can be a security risk. .gitignore helps prevent accidental\n   inclusions.\n\n * Improving Performance: Git is more efficient when it doesn't have to track or\n   process irrelevant files, which is particularly useful in large projects.\n\n\nFILE AND PATTERN IGNORANCE\n\n * Specific Files: Add the file's name to the .gitignore file.\n\n * File Extensions: Use wildcards to ignore entire file types based on\n   extensions, such as *.log for all log files.\n\n * Folders: Directories can be ignored using / at the end to denote a folder,\n   like logs/.\n\n\nGLOBAL VS. LOCAL\n\n * Global Settings: You can set up a global .gitignore file for your system.\n   Anything listed here is ignored across all repositories on your local system.\n\n * Project-Level Settings: Each Git repository can have its own .gitignore file,\n   tailored to the specific requirements of that project.\n\n\nVERSION CONTROL\n\nWhile the .gitignore file itself is used for local Git operations and is\ntypically not committed or pushed to the remote repository, the ignoring\nbehavior it defines is subject to version control. This means that once you've\ncommitted a new or modified .gitignore file to a repository, the specified file\npatterns will be ignored by Git for the repository's lifetime.\n\n\nEXPERT INSIGHT: TIPS FOR EFFECTIVE .GITIGNORE FILES\n\n 1. Start Simple: Begin by ignoring basic OS-generated files and build\n    artifacts.\n 2. Use Templates: Many projects and languages have community-recommended\n    .gitignore templates to get you started.\n 3. Override Global Ignores: Sometimes, there might be project-specific\n    exceptions to your global ignore list.\n 4. Be Mindful of Dependencies: Depending on your ecosystem, certain\n    dependencies might have their unique .gitignore requirements.","index":63,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"65.\n\n\nHOW WOULD YOU IGNORE FILES GLOBALLY?","answer":"To globally ignore files in Git, designate those file patterns in the\n~/.gitignore_global file. Then, link this file to your Git configuration.\n\n\nSTEPS TO GLOBALLY IGNORE FILES\n\n 1. Create Global Git Ignore File:\n    \n    This file can be named gitignore_global or .gitignore_global. You can create\n    it using any text editor or the command line.\n    \n    * cmd: touch ~/.gitignore_global\n\n 2. Specify Files and Patterns to Ignore:\n    \n    Open the global .gitignore file and list filenames, file patterns, or folder\n    paths to ignore. Each entry should be on a new line.\n    \n    Example:\n    \n    # Ignore backup files\n    *~\n    # Ignore .DS_Store on Mac\n    .DS_Store\n    \n\n 3. Inform Git about the Global Ignore File:\n    \n    Configure Git to reference this global ignore file.\n    \n    * cmd: git config --global core.excludesFile ~/.gitignore_global\n\n\nADVANTAGES OF GLOBAL GIT IGNORE\n\n * Consistency: Team members adhere to the same ignore patterns.\n * Customization: Tailor ignore directives across all repositories rather than\n   repeating them in individual repo .gitignore files.\n\n\nBEST PRACTICES\n\n * Use with Caution: Global ignores can inadvertently hide files meant for\n   version control.\n * Combine with Local Ignores: Include repository-specific ignores to cater to\n   unique needs.\n * Review Regularly: Ensure the global .gitignore file remains up-to-date and\n   relevant.\n\n\nCODE EXAMPLE: SETTING UP GLOBAL GIT IGNORE FILE\n\nHere is the Bash code:\n\n# Create the global ignore file\ntouch ~/.gitignore_global\n\n# Open the global ignore file and add contents\necho \"*.log\" >> ~/.gitignore_global\n\n# Inform Git about the global ignore file\ngit config --global core.excludesFile ~/.gitignore_global\n","index":64,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"66.\n\n\nHOW DO YOU ENSURE YOUR COMMITS ARE SIGNED WITH YOUR GPG KEY?","answer":"To ensure that commits are consistently signed using a GPG key, you need to\nconfigure your Git tools and repository settings accordingly.\n\n\nKEY STEPS TO ENSURE COMMIT SIGNING\n\n 1. Check Global Configuration: Verify your git global setting is designated to\n    sign commits by default:\n    \n    git config --global commit.gpgsign true\n    \n    \n    If not, set it with:\n    \n    git config --global commit.gpgsign true\n    \n\n 2. Verify Local Settings: Individual repositories might override global\n    settings. Ensure that the local setting follows the global one by running:\n    \n    git config commit.gpgsign\n    \n    \n    The expected output should be true.\n    \n    If the local setting is not set or differs from the global one, fix it with:\n    \n    git config commit.gpgsign true\n    \n\n 3. Commit Sign Status: To affirm that your commits are signed, use:\n    \n    git log --show-signature\n    \n    \n    If the status flag shows \"G\", the commit is properly signed with your GPG\n    key.","index":65,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"67.\n\n\nWHAT ARE SOME COMMON SECURITY PRACTICES FOR GIT REPOSITORIES?","answer":"Let's look at git repositories and their associated security practices in\ndetail:\n\n\nSECURITY THREATS TO GIT REPOSITORIES\n\nUNAUTHORIZED ACCESS\n\nHow: Through weak or shared SSH keys and compromised passwords.\n\nRisk: Contributors breach the repository, leading to data loss, malevolent\ncontributions, or codebase leaks.\n\nMALWARE AND CODE INJECTIONS\n\nHow: Locally running malicious scripts or directly pushing infected files to the\nremote repository.\n\nRisk: Codebase integrity and security can get compromised, leading to potential\nsystem vulnerabilities.\n\nDATA LEAKS AND ESPIONAGE\n\nHow: Stealthy sharing or publicizing sensitive information like API keys or\nconfidential documents through the repository.\n\nRisk: Exposure of sensitive data could lead to broader security breaches and\nregulatory fines.\n\nCommon Practices: Encrypt and manage access to sensitive files using services\nlike git-crypt or .gitignore.\n\nUNVERIFIED AND UNTRUSTED CONTRIBUTORS\n\nHow: Remote attackers pose as team contributors, infiltrating the repository.\n\nRisk: Codebase security and reliability concerns, leading to potential security\nvulnerabilities or data inconsistencies.\n\nCommon Practices to Mitigate Risks:\n\n * Review and Monitor Collaborators: Use user authentication and access\n   restrictions (like 2FA, SSH keys, and username/password) to assert user\n   identity.\n * Code Review: Enforce pull request reviews, especially on sensitive or\n   unverified changes.\n\nCODEBASE INTEGRITY BREACH\n\nHow: Any reversible or irreversible changes in the codebase content, structure,\nor origin-point.\n\nRisk: Loss of codebase integrity can jeopardize the code's functionality and\ncorrupt historical project records.\n\nREMOTE REPOSITORY THREATS\n\nHow: Threats to remote hosting services like GitHub, Bitbucket, or GitLab.\n\nRisk: Loss of code ownership, compliance with local and international cyber\nlaws, and unintentional publication might ensue.\n\n\nKEY SECURITY PRACTICES\n\nMULTI-FACTOR AUTHENTICATION (MFA)\n\nActivate MFA to add an extra layer of security. MFA can integrate with SSH,\nHTTPS, and GPG configurations.\n\nTOKEN AUTHENTICATION\n\nUse personal access tokens in place of account passwords, as these tokens are\nrevokable and minimally restrictive.\n\n# Config File\n[credential]\n  helper = store\n\n\nSSH KEYS\n\nSecure your SSH keys and ensure they are unique for each host machine and user.\n\nHTTPS\n\nFor ultimate security in transit, HTTPs is optimal. Git providers often support\nit.\n\nCODE SIGNATURES\n\nDigitally sign commits to ensure these originate from trusted sources.\n\ngit commit -S -m \"Signed Commit\"\n\n\nREGULARLY MONITOR LOGS\n\nCheck for suspicious timestamps, new and unverified users, or unknown IP\naddresses.\n\nUNVERIFIED PULL REQUESTS\n\nAny change from a contributor should be subject to reviews before integration.\n\nDATA RECOVERY MECHANISMS\n\nRegularly back up data. Also, keep in mind that private repositories across Git\nplatforms are backed up too.\n\nCREDENTIAL AND SECRET CONTROL\n\nUtilize gitignore to protect secret keys.\n\n# .gitignore\nsecrets/*\n!secrets/.gitkeep\n\n\nDIGITAL CERTIFICATES\n\nEnsure the integrity of public keys by availing digital certificates, especially\nin a GitLab environment.\n\n\nSECURE DEVELOPMENT WORKFLOW\n\n 1. Image Verification: Use Docker Content Trust for secure image distribution\n    in both development and production pipelines.\n\n 2. Code Analysis Tools: Integrate linters and security scanners into CI/CD\n    pipelines.\n\n 3. Branching Model: Employ a stringent Git branching model backed by strong\n    quality gates, code reviews, and a solid CI/CD process.\n\n 4. Secure Coding Guidelines: Enforce coding standards and security best\n    practices through strict version control.","index":66,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"68.\n\n\nHOW DO YOU ENCRYPT SENSITIVE DATA IN A GIT REPOSITORY?","answer":"Encrypting sensitive data in a Git repository is crucial for meeting privacy and\nsecurity requirements defined in frameworks like GDPR, HIPAA, and more.\nPotential sensitive information includes access tokens, private keys, and\nproblem-solving services, passwords, or other privileged information.\n\n\nCOMMON RISKS\n\n * Accidental Exposure: Team members might inadvertently duplicate or share\n   sensitive data.\n * Version History Vulnerability: Unauthorized access to a previous commit could\n   leak sensitive information.\n * Third-Party Integration Weakness: External tooling could inadvertently expose\n   sensitive data.\n\n\nDEFENSE METHODS\n\nGit repositories accommodate three primary methods:\n\n 1. Ignoring Files: Exclude sensitive files from version control using\n    .gitignore.\n 2. Static Keys: Leverage manual or tool-based solutions to encrypt sensitive\n    data.\n 3. **Dedicated Tools ** such as Git-crypt specializes in securing specific\n    files. Tools like BlackBox integrate selective file encryption with GPG.\n\n\nTOOLS FOR ENCRYPTED REPOSITORIES\n\nAmong several methods:\n\n 1. Git-Crypt: Encrypts specific files or directories using GPG.\n 2. Keybase: Integrates with Git to provide robust cryptographic capabilities.\n\n\nBEST PRACTICES\n\n * Automation: Rely on pre-commit and continuous integration to maintain data\n   security.\n * Testing: Validate encryption setups to ensure robust protection.\n * Management: Centralize data access control using a dedicated team or service.","index":67,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"69.\n\n\nWHAT ARE SOME STRATEGIES FOR CREDENTIAL STORAGE IN GIT?","answer":"While keeping credentials in version control isn't advisable, you can use one of\nthe following methods for safe deployment:\n\n\nBEST PRACTICES\n\n * Environment Variables: Ideal for production, inject credentials during\n   deployment without storing them in Git.\n * .gitignore File: Great for local development and temporary environments.\n\n\n.GITIGNORE METHOD\n\n 1. General Steps:\n    \n    * Add Your sensitive file(s) to .gitignore.\n    * Codes Example:\n    \n    # .gitignore\n    secrets.txt\n    \n    \n    * Commit this change: your sensitive files won't be included in future\n      commits.\n    * Special Note: .gitignore only affects untracked files. If a file was\n      already committed, adding it to .gitignore won't remove it from the\n      repository or other users' copies. You have to follow a special process if\n      you've committed a sensitive file by mistake.\n\n 2. Undoing a Mistake:\n    \n    * Remove the file from the Git history.\n    * Use git filter-branch: ```Git\n      git filter-branch --tree-filter 'rm -f secrets.txt' HEAD\n      \n      \n    \n    * Force-push to the remote repository. Be extremely careful with this action\n      as it can cause issues for other collaborators who may have worked on the\n      repository after your change.\n\n\nUSE GIT-CRYPT\n\nWHAT IS GIT-CRYPT?\n\nGit-Crypt lets you encrypt certain files in a repository, ensuring they are\nunreadable without an encryption key.\n\nSPECIFIC STEPS\n\n 1. Initialize Git-Crypt: Run the following commands:\n    \n    git-crypt init\n    git-crypt add secrets.txt\n    \n    \n    * This sets up the repository to use git-crypt and \"protects\" secrets.txt.\n    * If a collaborator doesn't have the encryption key, they won't be able to\n      read the file's contents.\n\n 2. Sharing The Key: Use a separate, secure mechanism to share the encryption\n    key with collaborators.\n\n 3. Handling Mistakes and Collaboration: If you accidentally commit a change\n    before encrypting or adding to git-crypt, you need to re-encrypt the file or\n    folder and then commit the updated encrypted version. Collaborators who\n    haven't decrypted the old version won't see any sensitive data.\n\n\nUTILIZE SECRET MANAGEMENT TOOLS\n\nCentralized tools like HashiCorp Vault or cloud-native solutions such as AWS\nSecrets Manager are popular choices to manage and distribute secrets securely.\n\nThese systems, often with additional security mechanisms like fine-grained\naccess controls and audit trails, can integrate with your CI/CD pipeline to\ndeploy secrets without exposing them in the Git history.","index":68,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"70.\n\n\nHOW WOULD YOU REVOKE ACCESS TO A GIT REPOSITORY?","answer":"To revoke access to a Git repository, you can use several methods, each suited\nto different scenarios. Here are the high-level options:\n\n\nREVOKE COLLABORATOR ACCESS\n\n * GitHub & GitLab: Navigate to repository settings and remove collaborators.\n\n * Bitbucket: Go to repository management and delete users or groups.\n\n\nREMOVE SSH KEYS\n\nFor hosted services, you can manage SSH keys in the user settings. Simply delete\nthe relevant key to revoke access.\n\n\nALTER PUSH / PULL PERMISSIONS\n\nOn self-hosted servers or with certain tools like Gitolite, you can revoke push\n/ pull access for specific users or groups.\n\n\nREFACTOR REPOSITORY URLS\n\nMigrating your Git repository to a new URL, for instance by changing the remote,\neffectively revokes access to the old repository.","index":69,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"71.\n\n\nHOW DO YOU FIND AND RESTORE A DELETED FILE IN A GIT REPOSITORY?","answer":"Git allows you to restore deleted files using both the command line and\ngraphical user interfaces.\n\n\nUSING COMMAND LINE\n\nTo restore a deleted file, you can use the git checkout command and specify the\ncommit or branch where the file existed. You can alternatively use git restore\nin modern versions of Git.\n\n\nSYNTAX: GIT CHECKOUT\n\ngit checkout <commit> -- <file>\n\n\n\nSYNTAX: GIT RESTORE (MODERN GIT)\n\ngit restore --source=<commit/branch> <file>\n\n\nHere, <commit> is the commit ID, and <file> is the name of the deleted file.\n\n\nEXAMPLE:\n\ngit checkout abc123 -- deleted_file.txt\n\n\nor\n\ngit restore --source=abc123 deleted_file.txt\n\n\n\nUSING GRAPHICAL USER INTERFACES\n\nMany git interfaces, such as Sourcetree and GitHub Desktop, offer ways to view\nand restore deleted files through an intuitive graphical representation of\ncommits and file states.\n\n\nPOTENTIAL CHALLENGES\n\nWhile these methods can effectively restore locally deleted files, recovering\nfrom a remote repository or a shared git history has more complexities.\nTechniques involving revert or reset operations can introduce problems in a\ncollaborative environment and should be approached with caution.\n\nThe best practice is to use these methods on unshared/local repositories and\nmake sure to communicate with the team before using such operations on shared\nones.","index":70,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"72.\n\n\nWHAT STEPS WOULD YOU TAKE IF YOU ACCIDENTALLY COMMITTED SENSITIVE DATA?","answer":"Great care should always be taken while committing changes in Git. However, if\nsensitive data does get committed, swift actions are necessary to mitigate\npotential security risks.\n\n\nSTEPS TO REMOVE SENSITIVE DATA FROM GIT HISTORY\n\nIDENTIFY AND REMOVE SENSITIVE INFORMATION\n\n 1. Revoke Sensitive Access: If the leaked data includes credentials or keys,\n    deactivate them immediately.\n\n 2. Remove or Secure Files: If you haven't pushed the changes yet, remove the\n    sensitive files from your file system. If the changes are already published,\n    you can move or delete files from your repository and then push again.\n    \n    Since history rewriting can be risky, it's best to save these steps for\n    sensitive information leaks only.\n\nUSE .GITIGNORE\n\nPrevent sensitive files from accidentally being committed by adding them to a\n.gitignore file. If you discover that sensitive files are tracked, it is\nessential to follow an additional sequence of steps:\n\n 3. Update .gitignore: Make sure the sensitive files are now part of the\n    .gitignore list.\n\n 4. Remove Tracked Files: This will remove the sensitive file from the current\n    state:\n    \n    git rm --cached path/to/sensitive_file\n    \n    \n    > This line also removes the file from Git's staging area. If there are any\n    > pending changes, make sure to commit them first.\n\n 5. Amend .gitignore: Commit the updated .gitignore file.\n\n 6. Push Updates: Finally, push your changes to overwrite the remote repository.\n\nImplementing .gitignore retroactively requires care, especially when dealing\nwith files that are already tracked. It's advisable to combine it with the steps\nto re-write history where necessary.\n\nUSE THE GIT FILTER-BRANCH TOOL\n\ngit filter-branch is a powerful tool that can be used to clean sensitive data\nfrom the history. However, it should be used with caution, as it rewrites commit\nhistory, potentially causing synchronization issues for others working on the\nsame repository.\n\n 1. Identify Files: To rewrite history up to a particular commit, use:\n    \n    # Example for a single file\n    git filter-branch --tree-filter 'rm -f path/to/sensitive_file' HEAD\n    \n\n 2. Unpublish All Past Commits: After using git filter-branch, ensure that you\n    overwrite the entire remote history. All team members who have the\n    repository must also rebase, which can be disruptive.\n\nUSE GIT PUSH --FORCE\n\nAfter cleaning your local repo history (or the upstream remote, if you have\npermission):\n\ngit push --force\n\n\nWarning: --force updates the remote like a standard push, but it does not\nintegrate the significant updates with other developers' work. It can lead to\ndata loss and should be used with caution. If you're working in a shared\nenvironment, this can cause issues for other team members. They might end up\nwith conflicting updates that need manual resolution.\n\nDOCUMENT CHANGES AND NOTIFY THE TEAM\n\nDocument all the changes made, especially if you had to force-push. You can use\na clear commit message to explain the necessary steps for the collaborators.\n\n\nBEST PRACTICES TO PREVENT DATA LEAKS\n\n 1. Regular scrubs: Ensure that you are following a schedule to remove old\n    credentials.\n 2. Separate Environments: Use different configurations for development,\n    testing, and deployment. This way, you won't inadvertently use production\n    keys during development.\n\nTaking these best practices into account, in addition to swift action if\nsensitive data is accidentally committed, will help protect your data and that\nof your team.","index":71,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"73.\n\n\nHOW DO YOU HANDLE DETACHED HEAD STATE IN GIT?","answer":"Detached HEAD state in Git is a situation where the checked-out commit is not\nlinked to a branch. While it's useful for inspecting past work or particular\ncommits, it's important to understand how to manage this state.\n\n\nRISKS OF DETACHED HEAD STATE\n\n 1. Data Loss: Commits in this state won't be \"pointed\" to by any branch, and\n    can be lost if you check out a new branch or reset.\n 2. Confusion: Future changes might not be in the context of any particular\n    branch, making tracking, merging, and debugging harder.\n\n\nBEST PRACTICES\n\n * Create a Branch: If you intend to make changes, always create a new branch\n   from the detached HEAD state.\n\n * Use Branch Names or Commit Hashes: To avoid unintended data loss, use branch\n   names or commit hashes when checking out specific commits.\n\n * Review Intentions: Ensure you understand why you're in a detached HEAD state,\n   and exit it promptly after the necessary inspection or action.\n\n\nCOMMON EXIT STRATEGIES\n\n * Discard Changes: If you have uncommitted changes and wish to discard them:\n   \n   git checkout -- .\n   \n\n * Commit Changes: If you want to commit your changes:\n   \n   git checkout -b new-branch-name\n   git add .\n   git commit -m \"Saved changes from detached HEAD\"\n   \n\n * Merge Changes: To merge your changes into an existing branch:\n   \n   # If not on the target branch\n   git switch target-branch\n   git merge HEAD@{1}\n   \n\n * Reattach HEAD to a Branch Without Merging or Creating a New Commit:\n   \n   git switch -\n   \n\n\nPREVENTING DETACHED HEAD STATE\n\nProactively using these best practices can often prevent accidental entry into\nthe detached HEAD state.\n\n\nCODE EXAMPLE: BEST PRACTICES FOR HANDLING DETACHED HEAD\n\nHere is the code:\n\n# Check out a specific commit using its hash\ngit checkout c9a1b26\n\n# Realize you need to make changes and create a new branch\ngit checkout -b fix-typo\n\n# Make changes, add and commit\ngit add file.txt\ngit commit -m \"Fixed a typo\"\n\n# Reattach to the previous branch without creating a new commit\ngit switch -\n","index":72,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"74.\n\n\nEXPLAIN HOW TO RECOVER A DROPPED STASH IN GIT.","answer":"Stashes in Git are a temporary storage solution that allows you to set aside\nnot-yet-committed changes, mainly for tasks like hotfixes and context switches.\n\nShould you accidentally drop a stash, Git provides a reflog mechanism\nspecifically designed to help you recover such lost references, including\nstashes. Here is the exact recovery procedure.\n\n\nRECOVERING A DROPPED STASH\n\n 1. Remind Yourself of What Was In the Dropped Stash:\n    \n    * Use gitk --all to visualize the commit history, including stashes and\n      their associated commits. Alternatively, HexFiend, a hexadecimal editor,\n      can be employed to inspect and recover the object.\n\n 2. List All Stash References:\n    \n    git fsck --no-reflogs | awk '/dangling commit/ {print $3}'\n    \n\n 3. Find the SHA of the Dropped Stash:\n    \n    * Look through the log of the stash to identify the commit resetting the\n      reference. Execute:\n      \n      git fsck --no-reflogs\n      \n    \n    * This will display a list of all commits, including the one resetting the\n      reference.\n\n 4. Recover the Dropped Stash:\n    \n    * Use git stash and specify the commit hash to recover the associated stash\n      object:\n      \n      git stash apply stash@{<commit-hash>}\n      \n    \n    * Alternatively, utilize the reflog to get back the stashed changes:\n      \n      git reflog stash apply <stash-reference>\n      \n\n 5. Verify Restoration:\n    \n    * Confirm that the desired changes are present with:\n      \n      git stash list\n      \n\n 6. Clear the Reflog for Housekeeping:\n    \n    * Once the recovery is successful and verified, use the following command to\n      clean up the reflog:\n      \n      git reflog expire --expire=now --all\n      \n      \n      This will ensure that other developers aren't mislead by now irrelevant\n      reflog entries.","index":73,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"75.\n\n\nHOW DO YOU AMEND THE MESSAGE OF THE LAST COMMIT?","answer":"To amend the last commit message in Git:\n\n 1. Access Command-Line: Open your terminal or Git Bash.\n 2. Navigate to Repository: Use the cd command to move to the project's\n    directory.\n 3. Amend with Flag: Use git commit --amend -m \"New commit message\" to revise\n    the commit message.\n\nAfter running the commit --amend command, the default text editor opens where\nyou can edit the message. If you want to skip the text editor and provide a new\nmessage directly, simply include the -m flag and the updated message in quotes.\n\n\nCODE EXAMPLE\n\nHere is the complete code:\n\n# Navigate to repository\ncd /path/to/repository\n\n# Amend the commit message\ngit commit --amend -m \"Updated commit message\"\n","index":74,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"76.\n\n\nWHAT IS A PULL REQUEST AND HOW DOES IT WORK?","answer":"Pull Request (PR) serves as a formalized mechanism for initiating code review,\nproviding a platform for team collaboration in a controlled environment. It is\ninstrumental in contributing to open source projects and other distributed team\nworkflows.\n\n\nCORE COMPONENTS\n\n 1. Branches: Git's version control system helps manage the history of multiple,\n    parallel lines of development called \"branches.\"\n\n 2. Repositories: Separate, yet potentially connected, collections of files and\n    their history, most commonly remote-tracking with Git.\n\n\nWORKFLOW\n\n * Initiation: Developers, working from their local clones of a repository,\n   create a unique branch to isolate the changes they intend to propose.\n\n * Integration: Once the changes are complete, the source branch may be merged\n   into the feature branch to ensure compatibility. This step might involve\n   regular rebasing in a non-linear history.\n\n * Request: A formalized request for code review and potential integration is\n   sent to the repository's maintainers through the PR.\n\n * Review: The proposed changes are thoroughly examined for style,\n   functionality, and potential issues.\n\n * Adjustment: Feedback from the code review might necessitate further changes,\n   requiring additional work on the feature branch.\n\n * Merging: Once the reviewers indicate their approval, the PR is merged into\n   the repository's primary branch, typically main or master.\n\n\nKEY CONCEPTS\n\n * Code Review: PRs lay a foundation for thorough, critical assessments of\n   contributed code.\n\n * Automatic Checks: Many collaborative platforms, such as GitHub, can run\n   automated tests to verify the proposed changes.\n\n * Conflict Resolution: Should the target branch evolve during the PR's life\n   cycle, developers must resolve any conflicting changes.\n\n * Communication and Documentation: PRs serve as a basis for team-wide\n   discussions and logging the evolution of a project.\n\nYou should add the Coordination, Amplified Application, Long-Term Impact of\nDecisions and best Context for usage.","index":75,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"77.\n\n\nHOW DO YOU UPDATE A PULL REQUEST?","answer":"In a version control workflow like Git, developers frequently update pull\nrequests in response to feedback and changes to the base branch. This process\ninvolves the following steps:\n\n 1. Fetch & Rebase: Ensure your local branch is up-to-date with the base branch.\n 2. Resolve Conflicts (if any): Merge any conflicting changes between the\n    branches.\n 3. Push Changes: Update the remote branch (i.e., your pull request).\n 4. Request Review: Notify collaborators that your pull request is updated.\n\nLet's explore each step in detail.\n\n\nDETAILED STEPS TO UPDATE A PULL REQUEST\n\n1. FETCH & REBASE\n\nFirst, ensure that your local branch is in sync with the base branch (usually\nmain or master).\n\n# Navigate to your local branch\ngit checkout your-feature-branch\n\n# Get remote changes\ngit fetch origin\n\n# Update your branch to incorporate remote changes, using rebase to maintain a clean history\ngit rebase origin/main\n\n\n2. RESOLVE CONFLICTS\n\nIf there are any conflicting changes between your branch and the base branch,\nyou need to resolve these conflicts. After resolving the conflicts, you continue\nthe rebase process or alternatively use --continue after resolving the\nconflicts.\n\n# Git will mark the conflicted files; edit the files to resolve conflicts\n# After resolving, continue the rebase process\ngit rebase --continue\n\n\n3. PUSH CHANGES\n\nOnce the rebase is successful and any conflicts are resolved, push your updated\nbranch (i.e., your pull request).\n\n# Push the changes to the remote branch\ngit push origin your-feature-branch\n\n\nIf you have force-pushed previously (which you should avoid in some team\nsettings due to potential issues), the command becomes:\n\ngit push origin your-feature-branch --force-with-lease\n\n\n4. REQUEST REVIEW\n\nLastly, communicate with your team members or collaborators, asking them to\nreview your changes in the pull request.\n\n\nDISALLOWED 'PUSH --FORCE' ON SHARED BRANCHES\n\nForce-pushing can rewrite the commit history, causing issues for anyone else\nworking on the same branch. It's recommended to use force-pushing only on your\npersonal branches and when no one else is working on them.\n\nIn a shared setting, the --force-with-lease flag is a safer alternative,\nsafeguarding against unintended overwrites. It checks if the remote branch has\nbeen updated since you last fetched changes.\n\n\nGIT CONFIGURATIONS FOR SAFER WORKFLOW\n\nYou can set up configurations to help prevent accidental force-pushes:\n\n * push.default: With the global configuration option push.default, you can\n   define the default behavior of git push without specifying a specific remote\n   and branch. For shared branches, use simple, which ensures changes are pushed\n   only if the current local branch is configured to push to the same named\n   remote branch.\n\n * rebase.autosquash: When set to true, Git will automatically commit during a\n   rebase if the commit message begins with \"squash!\" or \"fixup!\".\n\n * pull.rebase: If set to true, it ensures that every git pull behaves like a\n   git pull --rebase rather than a merge, streamlining the commit history.\n\nCOMMITS IN A PULL REQUEST\n\nEach commit in your pull request should reflect a single logical change and\nmaintain a clear commit message. The commit history should be coherent and\nstreamlined, avoiding clutter with unnecessary or tangential changes.\n\n\nBEST PRACTICES\n\n 1. Frequent Updates: Regularly incorporate feedback and keep your pull request\n    up-to-date.\n 2. Clear Commit Messages: Use descriptive commit messages to explain the\n    rationale behind changes.\n 3. Relevant Changes Only: Focus on including changes that directly relate to\n    the pull request's objective.","index":76,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"78.\n\n\nWHAT IS A CODE REVIEW PROCESS IN GIT?","answer":"In a code review process, the focus is on quality, correctness, maintainability,\nand performance of code. Code review is a crucial stage in any Git development\nworkflow, where individuals or teams examine the code and provide feedback\nbefore it's integrated into the codebase.\n\nCode reviews can be asynchronous or synchronous but are most effective when\nthey're collaborative.\n\nThe typical steps in a code review include:\n\n 1. Initiation: Triggered when a developer or team wants a code change reviewed.\n 2. Selection: One or more reviewers are chosen.\n 3. Inspection: The code is evaluated by the reviewers for adherence to\n    standards, best practices, and other criteria.\n 4. Discussion and Iteration: Any issues or concerns are discussed, and further\n    changes may be requested.\n 5. Signing Off: Reviewers approve the code for integration or suggest further\n    improvements.\n\n\nBEST PRACTICES FOR CODE REVIEW\n\n * Show, Don't Tell: When commenting, provide specific examples or solutions if\n   possible.\n * Keep It Small: Review only a few changes at a time. It's easier to miss\n   important details in large reviews.\n * Avoid Personal Remarks: Focus on the code, not the person who wrote it.\n * Mind the Context: Understand the bigger picture, code history, and the\n   problem the code solves.\n * Use Tools Wherever Possible: Many tools provide automated checks that can\n   complement manual reviews.\n * Encourage Continuous Learning: Use review comments as a learning opportunity\n   rather than a critique.\n\n\nBENEFITS OF CODE REVIEW\n\n * Quality Assurance: Catch bugs, security issues, and architecture problems\n   early on.\n * Knowledge Sharing: Code reviews are a great way for team members to learn\n   from each other.\n * Team Building: Collaborative reviews foster a culture of trust, respect, and\n   continuous improvement.\n * Standard Adherence: Ensures code aligns with coding standards, best\n   practices, and design principles.\n * Identifying Technical Debt: Any deviation from coding standards or best\n   practices can point to areas needing attention.\n\n\nCODE REVIEW TOOLS\n\n * GitHub/GitLab: Offer built-in PR and code review features.\n * Bitbucket: Allows for inline feedback directly on the diffs.\n * Gerrit: A specialized tool for Git code review, convenient for large teams.\n * Reviewboard: Another standalone code review tool that integrates with Git.\n\n\nBEST PRACTICES FOR VERSION CONTROL IN CODE REVIEW\n\n * Keep Revisions Updated: Synchronize your working copy with the remote\n   repository before initiating a code review.\n * Clear Commit Messages: Write concise but descriptive commit messages to\n   provide context to reviewers.\n * Use Branches Judiciously: Feature branches make reviews more manageable. A\n   single branch should generally correspond to a single work unit or task.","index":77,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"79.\n\n\nHOW DO YOU HANDLE A PULL REQUEST CONFLICT?","answer":"Dealing with pull request conflicts is an integral part of collaborative\ndevelopment on Git. Here are the key steps:\n\n 1. Resolve Conflicts Locally or Online: Git generally provides two methods to\n    resolve conflicts:\n    a. Locally: After pulling the latest changes from the remote repository, you\n    can resolve conflicts using a Git client that provides a merge tool or\n    manually through your code/IDE.\n    b. Online: Some platforms like GitHub allow for resolving conflicts directly\n    within the pull request interface, especially when working with web content\n    or single-file merges.\n\n 2. Review Changes: Regardless of the method used to resolve the conflict, it's\n    important to review the changes and ensure that the resolution is\n    satisfactory.\n\n 3. Commit Resolved Changes: After resolving the conflict, ensure that you\n    commit the changes. In some environments, this might entail creating a merge\n    commit.\n\n 4. Test and Verify: Before merging your pull request, it's best practice to\n    thoroughly test the changes, especially if you've had to resolve a conflict.\n\n 5. Merge: Once everything checks out, merge your pull request either through\n    the Git client or the platform where your repository is hosted.\n\nHere is the code:\n\n\n# Fetch changes from remote\ngit fetch origin\n\n# Switch to target branch\ngit checkout target-branch\n\n# Merge changes from source\ngit merge origin/source-branch\n\n# Resolve conflicts and stage changes\n# After resolving, `git status` will show staged changes\ngit add .\n\n# Commit resolved changes\ngit commit -m \"Merged source-branch into target-branch\"\n\n# Push to remote\ngit push origin target-branch\n","index":78,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"80.\n\n\nWHAT IS THE DIFFERENCE BETWEEN GIT PULL AND GIT FETCH FOLLOWED BY GIT MERGE?","answer":"Let me explain the key differences between git pull and git fetch combined with\na git merge. Both are used to synchronize a local git repository with its remote\ncounterpart.\n\n\nGIT PULL\n\n * One-Step Process: git pull integrates changes from the remote repository,\n   executing both the git fetch and the merge or rebase (based on repository\n   configuration) in one go.\n\n * Quick Summary: It provides a fast overview of changes occurring between the\n   local and the remote copies and then syncs those changes directly.\n\n * Merge or Rebase on Auto-Pilot: The strategy for combining changes can be\n   pre-configured. By default, it executes a merge but can be set to rebase.\n\nWHEN TO USE GIT PULL\n\n * For a Quick Update: If you want a comprehensive, one-step update of the local\n   repository with potential conflict resolution.\n\n * To Optimize Your Workflow: It might streamline the process compared to\n   executing git fetch followed by a merge or rebase.\n\n\nGIT FETCH & GIT MERGE\n\n * Flexible Two-Step Process: This combination lets you customize how you want\n   to integrate changes. After git fetch, you can inspect and decide whether to\n   integrate the fetched changes using git merge.\n\n * In-Depth Overview of Changes: After executing git fetch, which fetches the\n   changes from the remote repository, you can examine the updates to see\n   whether they are ready to be merged or require any adjustments.\n\nWHEN TO USE GIT FETCH & GIT MERGE\n\n * When You Prefer Control: For finer control over when and how changes from the\n   remote repository are integrated, such as after reviewing the modifications\n   fetched from the remote.\n\n * For Collaborative Merging: Useful during collaborative efforts, especially\n   when multiple team members are contributing to the same project.\n\n\nWHICH ONE TO CHOOSE?\n\nSelecting the right synchronization approach depends on your workflow and need\nfor granularity in managing remote changes.\n\n * For a streamlined, one-step update: Choose git pull.\n * For finer control before integrating remote changes: Opt for git fetch\n   followed by the specific integration method (git merge or git rebase).\n\nIn most scenarios, both methods are equally effective for synchronizing your\nlocal and remote repositories.","index":79,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"81.\n\n\nHOW DO YOU HANDLE LARGE FILES IN GIT?","answer":"Managing large files in Git can be challenging as it's designed to track changes\nin text files efficiently.\n\nTo handle large files, you can utilize Git Large File Storage (LFS) or explore\nother specialized tools.\n\n\nGIT LFS\n\nGit LFS is a file management solution designed for large files. It replaces\nlarge files in your commit history with text pointers that reference the actual\nfiles stored in a remote server.\n\nSETTING UP GIT LFS IN A REPOSITORY\n\n 1. Install Git LFS using your package manager or download from the website.\n\n 2. In your Git repository, run:\n    \n    git lfs install\n    \n\n 3. Track file types with LFS using:\n    \n    git lfs track \"*.extension\"\n    \n    \n    All files matching the specified extensions are now handled by LFS.\n\n 4. Add and commit your changes as usual.\n\n 5. Push the changes to your Git LFS-enabled repository. The large files will be\n    stored on the LFS server.\n\nCLONING A REPOSITORY WITH LFS FILES\n\n * When you clone an LFS-enabled repository, LFS files are downloaded alongside\n   the repository files.\n * If LFS is not set up, files will be text pointers. Run:\n   \n   git lfs install\n   \n\n\nOTHER TOOLS\n\nSeveral tools and services are optimized for handling large files with Git,\noffering dedicated features such as version control for large datasets, large\nmedia, and more. Some of these tools include:\n\n 1. Conda: Often used for data science, conda specializes in managing large data\n    and libraries. It's integrated with Git for version control.\n\n 2. DVC (Data Version Control): A version control system specialized for data\n    science and machine learning projects, DVC provides data and model\n    management using Git.\n\n 3. Beanstalk: It's a platform optimized for version control of large files,\n    especially in graphic design and web development.","index":80,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"82.\n\n\nWHAT ARE SOME WAYS TO IMPROVE THE PERFORMANCE OF A LARGE GIT REPOSITORY?","answer":"Managing large Git repositories can be challenging, especially when it comes to\nperformance. Here are some strategic and technical measures to optimize the\nperformance of large Git repositories.\n\n\nBEST PRACTICES FOR LARGE REPOSITORIES\n\n * Mono-Repo vs. Multi-Repo Management: Many companies managing multiple\n   projects face the question of whether to go multi-repo or mono-repo. A\n   mono-repository contains all of the source code for many projects, while a\n   multi-repository approach maintains separate repositories for different\n   projects or components. Both approaches have their pros and cons.\n   \n   Mono-Repo Benefits\n   \n   * Project-wide changes: It's easier to make global changes.\n   * Centralization: All code is in one place, meaning developers only need to\n     clone one repository.\n   * Ease of discovery: It's easier to find related projects.\n   \n   Challenges of Mono-Repos\n   \n   * Performance: This can become a bottleneck with larger repositories.\n   * Versioning: It can be challenging to version independent projects.\n   * Repository management: It might become challenging to handle a massive\n     codebase, often leading to a lack of modularity.\n   \n   Multi-Repo Benefits\n   \n   * Versioning: Each project is versioned independently.\n   * Isolation: Each component's history, metrics, and the codebase stand\n     independently.\n   * Easier management: It's generally easier to manage and work with smaller\n     repositories that each serve a focused purpose.\n   \n   Challenges of Multi-Repos\n   \n   * Cross-Project changes: Coordinating changes across projects can be more\n     challenging.\n   * Discoverability: Finding related projects can take additional effort.\n   * Initial Setup: New developers might need to clone multiple repositories.\n\n * Code Modularization: Breaking down large sections of your codebase into\n   smaller, more manageable modules or packages helps Git to handle the change\n   history more efficiently.\n\n * Smart GIT Techniques: Use techniques like shallow and sparse checkouts where\n   appropriate.\n\n\nTECHNICAL PERFORMANCE ENHANCEMENTS\n\n * Garbage Collection: Regularly running both local and central server-side GC\n   can help optimize the repository.\n\n * Packing: Repacking objects with git repack can improve repository\n   performance.\n\n * Index Monitoring: Git can track if the index (staging area) is unchanged and\n   only update file metadata during checkout when the index is still valid.\n\n * Loose Objects vs. Packfiles: Avoid an excessive amount of loose objects\n   (unpacked object files) as these tend to slow down Git's performance.\n   Consider packing them into packfiles with commands like git gc or git repack.\n\n * Index File Size: Large index files slow down Git commands that read from\n   them, such as status, checkout, and commit.\n\n * Delta Compression: Delta compression aims to reduce the size of file blobs by\n   storing only the differences between versions.\n\n * Use Git LFS: For large files that do not compress well, or text files updated\n   frequently, consider using Git Large File Storage (LFS).\n\n * Reference Repositories: Unrelated to the user's local operations and storage,\n   Git can utilize reference repositories for data.\n\n * Profile Repository: The git gc --prune=<date> command is useful for keeping\n   recent changes and discarding old ones.\n\n * Parallelism: Some Git commands support parallel execution.\n\n * File System Caching: Locally cached data from your file system might impact\n   Git's performance.\n\n * Avoid Costly Operations: Certain Git operations can be resource-heavy, like\n   rebases, merges, and large history traversal.\n\n\nVERSION CONTROL BEST PRACTICES FOR TEAMS\n\n * Atomic Commits: Keep each commit focused on a single, well-defined task.\n\n * Decentralized Workflow & Topic Branches: Encouraging a decentralized workflow\n   ensures that developers can work independently and avoid conflicts whenever\n   possible.\n\n * Code Reviews: Integrate robust code review processes, ensuring that committed\n   code meets quality standards.\n\n * Merge Workflow: Utilize merge strategies that suit your team, codebase size,\n   and release schedules.\n\n * Collaboration Tools: Use tools, such as issue trackers and project management\n   boards, that integrate seamlessly with Git to streamline team collaboration.\n\n * Task Automation: Automate repetitive or error-prone tasks through CI/CD\n   pipelines and pre-commit hooks to reduce unpleasant surprises.","index":81,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"83.\n\n\nWHAT IS A SHALLOW CLONE IN GIT AND WHEN WOULD YOU USE IT?","answer":"A shallow clone in Git is a reduced clone that fetches only the most recent n\ncommits from the repository history. This feature is especially handy for\nworking on large projects with extensive histories because it speeds up the\ninitial clone time and reduces disk space usage.\n\n\nBENEFITS\n\n * Efficiency: Faster initial clone and less memory usage.\n * Security: Limits exposure to history for sensitive projects.\n * Privacy: Quick access to the latest changes, maintaining confidentiality of\n   past commits in shared or public repositories.\n\n\nDRAWBACKS\n\n * Relying on Remote: It limits certain operations that expect a complete\n   history unless the remote repository is accessible during the operation.\n * Reduced Context: Local operations and tracking older revisions might be\n   challenging.\n * Potential Mismatches: Issues may arise when trying to merge or rebase into or\n   from an incomplete history.\n\n\nUSE CASES\n\n 1. Quick Fixes: For minor bug fixes or changes where the complete history is\n    not necessary.\n 2. Frequent Contributors: Developers who regularly need to fetch the latest\n    code but don't require the entire history can use shallow clones to save\n    time and resources.\n 3. Limited Resources: On devices with constrained disk space or memory, such as\n    mobile devices, where a full history isn't essential.","index":82,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"84.\n\n\nHOW DO YOU REDUCE THE REPOSITORY SIZE IN GIT?","answer":"To reduce repository size in Git, you can:\n\n 1.  Remove Untracked Files: Use git clean, with caution to avoid data loss, and\n     git clean -n for a dry run.\n\n 2.  Remove Large Files with BFG: The BFG Repo-Cleaner can find and remove large\n     files, reducing repository size. Consider linking to the official GitHub\n     page for BFG-repo cleaner as an external resource.\n\n 3.  Pack Objects and Prune: The git gc --aggressive and git repack commands\n     optimize repository storage.\n\n 4.  Use Shallow Clones: Limit the depth of history during cloning using --depth\n     for smaller clones.\n\n 5.  Split up Repositories: For modular projects, you can create separate\n     repositories for independent modules.\n\n 6.  Remove Unwanted Files and Folders: Use .gitignore to prevent specific files\n     or directories from being committed, and then remove them from the commit\n     history using git filter-branch or git rebase --interactive.\n\n 7.  Reduce Commit Size: Check in frequently, but when you do, make sure your\n     commits are optimal and not too large.\n\n 8.  Centralize and Archive: Ensure that you have a master, or \"canonical\"\n     repository that serves as the central hub, and regularly archive it to\n     prevent bloating.\n\n 9.  Prune Stale Objects: Remove all objects that are no longer being\n     referenced, git prune and git gc --prune keep the repository clean.\n\n 10. Keeping Track of the Repository Size: You can use git count-objects and\n     third-party tools to monitor repository size.\n\n 11. Care with Repositories in Remote Servers: Perform the cleanup in your local\n     repository first and then push the changes.\n\n 12. Educate Team Members: Encourage best practices across the development team.\n\n 13. Use Git-LFS for Large Files: Git LFS is a storage system that is optimized\n     for versioning large files. If your repo contains large files (such as\n     images, audio, or video files), consider using Git LFS.\n\n 14. Setting Up a Secure Network Communication: Ensure that the network you are\n     working on is secure before performing these operations.\n\n 15. Regular Reporting and Monitoring: Implement a regular reporting and\n     monitoring system to keep track of the repository size and take action when\n     necessary.","index":83,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"85.\n\n\nEXPLAIN HOW GIT LFS (LARGE FILE STORAGE) IS USED.","answer":"Git LFS streamlines the management of large files within Git repositories. It\nallows developers to reference large files or versions of files, without storing\nthem directly in the Git history.\n\nInstead, the files are handled by Git LFS, which replaces them with pointer\nreference files. These pointers are smaller and don't affect the repository's\nperformance, making collaboration more efficient.\n\n\nKEY CONCEPTS\n\n * Pointer Files: These small, lightweight text files are stored in the\n   repository. They act as placeholders, referencing where the actual large\n   files are stored.\n * File Locking: Git LFS offers an option to \"lock\" files, ensuring that only\n   one user can edit them at a time.\n * File Transfer: Large files are downloaded on a \"need-to-access\" basis, which\n   keeps the repository size small and ensures faster checkouts.\n\n\nWHY USE GIT LFS?\n\n * Versioning of Large Files: Git LFS enables the use of version control for\n   large files, without inflating the repository size.\n * Efficient Collaboration: Reducing the storage and transfer of large files\n   aids in smooth collaboration, especially in distributed teams.\n * Faster Checkouts: By fetching large files only when necessary, Git LFS makes\n   project checkouts quicker.\n * Cluster Compatibility: Git LFS is designed for use in clustered file systems,\n   allowing for even more expansive storage options.\n\n\nDISADVANTAGES OF USING GIT LFS\n\n 1. Increased Complexity: While Git LFS addresses certain limitations of Git,\n    its integration requires additional setup.\n 2. Centralized File Storage: This architecture can pose challenges, especially\n    in distributed teams, as all large files go through a central server.\n 3. Learning Curve: Teams and individuals who are new to Git LFS may encounter a\n    learning curve.\n 4. Potential Costs: Some Git LFS service providers may charge for storage,\n    introducing a financial consideration.","index":84,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"86.\n\n\nHOW DOES GIT INTEGRATE WITH CI/CD PIPELINES?","answer":"Git integrates with Continuous Integration/Continuous Deployment (CI/CD)\nworkflows to streamline software delivery. This streamlined process enhances\nsoftware quality, helps in faster delivery and vast improvement in time to\nmarket. Here are the key points on how Git integrates with CI/CD pipelines:\n\n\nINTEGRATION MECHANISMS\n\n * Webhooks and APIs: Git platforms provide customizable webhooks that trigger\n   build and deployment processes upon specific events, like a push to a branch.\n\n * Commit and Pull Request Validation: CI/CD tools can require successful builds\n   and tests before allowing merges, ensuring that the codebase stays stable.\n\n * Version Control Merging Strategies: With options such as regular merges or\n   pull request-based merges, teams can choose the approach that fits their\n   release and CI strategy.\n   \n   For example, you might see some teams where they make a lot of changes on\n   branches,\n   \n   Do the CI, do the tests as normal, and sometimes even merge into the master,\n   and then they might then run the CI again, once on the master before they\n   deploy.\n\n * Automated Workflows: CI/CD tools, often integrated with Git, provide flexible\n   workflows. A typical example includes separate stages for building, testing,\n   and deploying.\n\n\nVERSION CONTROL BRANCHING STRATEGIES\n\nLONG-LIVED BRANCHES\n\n * Master/Main Branch: Typically represents the production-ready state. CI/CD\n   pipelines are often triggered upon new commits to this branch.\n\nSHORT-LIVED BRANCHES\n\n * Feature/Branches: These branches are short-lived and feature-specific. CI/CD\n   can be configured to run automated tests on them.\n\n * Bug-Fix/Hotfix Branches: For urgent bug fixes in production, these branches\n   can be created from the Master/Main branch, and CI/CD pipelines can verify\n   and deploy them quickly.\n\n * Release Branches: Created from the Master/Main branch, these branches prepare\n   for production releases, undergoing additional testing and possible CI/CD\n   stages specific to the release process.\n\n\nCONTINUOUS DELIVERY VS. CONTINUOUS DEPLOYMENT STRATEGIES\n\n * Continuous Delivery: Git and CI/CD integration assist in making sure that the\n   codebase is always deployable to production. This might involve a manual step\n   between CI and CD.\n   \n   * Trigger Mechanism: Most commits (or ones merged into the main branch) are\n     set to trigger a CI build. However, the deployment to production might only\n     occur through a manual trigger or an additional artifact approval step.\n   \n   For example, you might have a workflow that on every successful merge to\n   master, the CI runs.\n   \n   But the artifacts from that CI aren't actually deployed until a developer or\n   a release manager provides an additional sign-off.\n\n * Continuous Deployment: Earmarks every successful build for automatic\n   deployment to production. This strategy is particularly common in SaaS\n   environments.\n   \n   * Direct and Automated Deployment: Any successful CI build, most often merged\n     into the main branch, triggers an automatic deployment.\n     \n     You might see it as on every successful merge to the Master, then the\n     deployment to the production happens after a pause, for some gating.","index":85,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"87.\n\n\nDESCRIBE THE PROCESS OF AUTOMATING DEPLOYMENTS USING GIT.","answer":"Automated deployments involve using pipelines for continuous deployment.\n\\textbf{Git} is often a central component through its webhooks or integrations\nwith deployment platforms.\n\n\nKEY COMPONENTS\n\n 1. Version Control: Git ensures different versions of code are recorded.\n\n 2. Trigger Mechanism: Automation is initiated through events like a merge to a\n    specific branch.\n\n 3. Build System: Code is converted into an executable format using tools like\n    Maven, Make, or Ant, and then tested.\n\n 4. Deployment Tools: Software and application artifacts are sent to servers or\n    staging areas.\n\n 5. Testing Rigs: Automated tests run to validate the code.\n\n 6. Configuration Management: Automated tools ensure consistency across various\n    deployments.\n\n 7. Monitoring & Logging: Post-deployment, the system is monitored and logs are\n    collected for analysis.\n\n\nINTEGRATION & WEBHOOKS\n\nGit platforms, such as GitHub, GitLab, and Bitbucket, provide integration with\ndeployment tools via webhooks. These webhooks are like triggers that initiate\nthe build and deployment for each push or merge event.\n\n\nDEPLOYMENT TOOLS\n\nMultiple platforms are available to automate deployment:\n\n * Jenkins: Often combined with Git to establish a continuous deployment chain.\n\n * Travis CI, Circle CI, others: Delivers cloud-based deployment solutions.\n\n * AWS CodeDeploy: Amazon's service streamlining deployments to EC2 instances or\n   on-premises computers.\n\n * Google Cloud Build: A build management solution from Google Cloud with\n   built-in continuous integration and continuous deployment (CI/CD)\n   capabilities.\n\n * Azure DevOps: A popular choice for Azure cloud deployments.\n\n * Heroku, Netlify, Vercel: Specifically for deploying web applications.\n\n\nMANUAL CONFIGURATION IN GIT\n\nIn your Git repository, you can define deployment scripts in a file like\n.gitlab-ci.yml (GitLab) or .travis.yml (Travis CI).\n\n\nAUTOMATION WITH GITPATRON\n\nThe auto parameter of the rpyc library (Remote Python Call) enables complete\nautomation using Git. Here's the modified process:\n\n 1. Version Control and Automated Testing:\n    \n    * Manual Action: Commit your changes and push to your Git repository.\n    * Automated Process: GitPatron regularly listens to repository events, such\n      as commits or pull requests, and triggers tests and other activities\n      automatically.\n\n 2. Trigger Mechanism and Code Validation:\n    \n    * Manual Action: Branch protection safeguards certain branches. For changes\n      to those branches, you create a pull request.\n    * Automated Process: GitPatron uses a subset of GitLab or GitHub\n      functionalities. When triggered by a Git event, it can clone the\n      repository and run basic syntax analysis to ensure no compilation errors.\n\n 3. Configuration Management and Code Optimization:\n    \n    * Manual Action: None.\n    * Automated Process: After testing, GitPatron analyzes commits and pull\n      requests. If a pattern violation is detected, it suggests the optimal\n      combination using AI.\n\n 4. Deployment Tools and Task Execution:\n    \n    * Manual Action: The administrator grants or revokes access to deployment\n      keys.\n    * Automated Process: If all tests pass, GitPatron can create deployment keys\n      and credentials automatically. It then deploys the code to the relevant\n      servers.\n\n 5. Verification and Post-Deployment Maintenance:\n    \n    * Manual Action: Regular monitoring and logging are essential for real-time\n      feedback.\n    * Automated Process: GitPatron ensures the systems are working after\n      deployment and triggers alerts if they're not.","index":86,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"88.\n\n\nHOW WOULD YOU CONFIGURE BRANCH PROTECTION RULES FOR A REPOSITORY IN THE CONTEXT\nOF CI/CD?","answer":"Branch protection rules ensure that specific workflows are followed before\nchanges are merged into a branch. This is especially important when integrating\nwith CI/CD pipelines.\n\n\nREASONING BEHIND BRANCH PROTECTION\n\nBy enforcing branch protection, you provide an additional layer of security and\nstability for your production environment. This helps in preventing unauthorized\nor untested changes from being deployed.\n\n\nKEY BRANCH PROTECTION SETTINGS FOR CI/CD INTEGRATION\n\n 1. Required Checks: Define which checks must pass before a merge. This is\n    typically the CI pipeline, ensuring code quality and test coverage.\n\n 2. Restrictions: Only authorized users or groups should be allowed to bypass\n    protection or make changes (such as merging to the main branch).\n\n 3. Disallowed Deletes: Branch protection should prevent force-pushes and\n    accidental branch deletions. Such actions can disrupt the CI/CD pipeline and\n    other workflows.\n\n 4. Required Reviews: Code reviews help maintain code quality. All merge\n    requests should meet the specified review requirements.\n\n\nVISUAL REPRESENTATION\n\nHere is the flow diagram:\n\nBranch Protection and CI/CD\n[https://res.cloudinary.com/de8awjcc8/image/upload/v1612024087/git-branch-protection_i06swy.jpg]\n\n\nSAMPLE BRANCH-PROTECTION RULE\n\nHere is the .git/config file:\n\n[branch \"main\"]\n    remote = origin\n    merge = refs/heads/main\n        [remote \"origin\"]\n    url = git@github.com:your-username/your-repo.git\n","index":87,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"89.\n\n\nWHAT ROLE DO GIT HOOKS PLAY IN AUTOMATION?","answer":"Git hooks enhance automation and streamline multi-user workflows by introducing\ncustom actions at crucial points. You can configure them to carry out tasks such\nas:\n\n * Code validation and testing\n * Enacting pre-defined workflows\n * Notifying team members about specific actions\n * Guarding against accidental mistakes\n * Further streamlining the developer's role in the software cycle\n\n\nKEY BENEFITS OF GIT HOOKS\n\n * Standardized Project Workflows: Hooks ensure that agreed-upon actions, like\n   code formatting or running specific tests, are automatically carried out.\n   This consistency across the team leads to better collaboration and code\n   quality.\n\n * Automated Quality Checks: By integrating hooks with code validation\n   processes, projects stay consistent and adhere to the predefined standards.\n   This reduces the need for manual intervention and the associated risks.\n\n * Reduced Error-Prone Operations: Hooks help limit common errors, like\n   committing incomplete code or sensitive information. This proactive approach\n   saves time and minimizes debugging and cleanup activities.\n\n * Workflow Flexibility: While Git provides standard workflows, hooks allow\n   teams to customize actions based on their specific project needs and\n   preferences.\n\n * Collaboration Enhancements: With hooks in place, developers are instantly\n   notified of specific events, ensuring timely coordination and knowledge\n   sharing within the team.\n\n * Streamlined Deployment: Select hooks, notably the post-receive one, assist in\n   delivering the latest code changes to the target environment, like a\n   production server.\n\n\nCODE EXAMPLE: GIT HOOK FOR AUTOMATED TESTING\n\nHere is a Bash script:\n\n#!/bin/bash\n\n# Check if script is setting up or destroying the hook\nif [[ $1 != \"commit\" ]]; then\n  exit 0\nfi\n\n# Run tests before allowing commit\necho \"Running tests before commit...\"\nif ./test.sh; then\n  echo \"Tests passed.\"\nelse\n  echo \"Tests failed. Fix them before committing.\"\n  exit 1\nfi\nexit 0\n","index":88,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"90.\n\n\nHOW CAN GIT HELP IN THE ROLLBACK PROCESS OF A FAILED DEPLOYMENT?","answer":"Git, with its branching and version control system, enables precise rollbacks,\nespecially in Continuous Deployment environments. Let's look at the specific\nfeatures Git offers for rollback management.\n\n\nEFFICIENT ERADICATION OF UNDESIRED CHANGES\n\nOne of Git's defining features is its ability to excise unwanted changes very\neffectively. This is essential in the context of rollback procedures. Two key\ncommands for accomplishing this are: git revert and git reset.\n\nGIT REVERT\n\nThis action is ideal for rolling back in a shared repository. It effectively\ncreates a new commit that counteracts the undesired changes, leaving a clear\nrecord of the restoration effort. This is particularly beneficial when working\nin a collaborative setting since it maintains the commit history intact.\n\nGIT RESET\n\nA reset, on the other hand, is a more forceful mechanism. It enables you to\nobliterate up to a certain point in your commit history. This can be both\npositive, allowing for targeted rollbacks, and perilous, given that it involves\nthe potential loss of data.\n\n\nSEAMLESS INTEGRATION WITH CI/CD PIPELINES\n\nOne of the many advantages of using Git for rollback management is its seamless\nintegration with modern CI/CD pipelines. This provides multi-tiered benefits:\n\n * Trigger Mechanisms: Events such as failed builds or automated tests can\n   trigger rollback, ensuring that the production remains stable, even in the\n   face of failed deployments.\n\n * Automated Deployment RollsBack: With git reset and other rollback\n   capabilities integrated within your CI/CD pipeline, quick and strategic\n   reversions become conveniently automated.\n\n\nHOLISTIC VISUALIZATIONS AND AUDITS\n\nGit's capacity for visualizing and auditing your codebase facilitates a\ncomprehensive understanding of both the current and past states. This stands at\nthe crux of any reliable rollback procedure, ensuring that all relevant changes\nhave been accounted for.\n\n * Branching Strategies: Leveraging distinct branches such as master for stable\n   releases and develop for ongoing work creates a clear delineation between\n   what's being deployed and what's still being developed and tested.\n\n * Visual Tools for History: Tools like git log enable a bird's eye view of the\n   commit history, helping track down the source of deployment issues\n   efficiently.\n\n\nEFFICIENT ROLLBACK PRACTICES\n\nTo maintain robust deployment procedures, combined with an array of Git's\nfeatures ensures standardized and controlled rollback measures.\n\n * Tagging: Before releases or deployments, leveraging Git's tagging feature\n   provides an uncomplicated method of referring back to stable versions.\n\n * Atomic Commits for Hotfixes: Keeping each hotfix or immediate patch in a\n   separate commit guarantees isolated rollbacks if necessary.\n\n\nBEST PRACTICES WITH GIT FOR EFFICIENT ROLLBACKS\n\n 1. Commit Sentry: Ensure each commit is succinct and achieves a discrete task,\n    making changes easier to track and reverse.\n\n 2. Comprehensive Testing: Never overlook the significance of thorough testing\n    before initiating or reverting deployments, especially in critical\n    production environments.\n\n 3. Auto-Deploy with Caution: While automating deployments expedites the\n    process, it's crucial to pair it with suitable testing mechanisms to prevent\n    accidental propagation of glitches.\n\n 4. Timely Rollbacks for Data Consistency: Recognize that inventory data stored\n    during deployments might be modified. Swift rollbacks not only minimize\n    business risk but also maintain data consistency.","index":89,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"91.\n\n\nHOW DO YOU INTEGRATE GIT WITH YOUR PREFERRED IDE?","answer":"Git and Git-based platforms like GitHub can be seamlessly integrated with\nvarious IDEs, offering a unified version control experience and streamlining\ndevelopment workflows.\n\n\nKEY IDES WITH GIT INTEGRATION\n\nVISUAL STUDIO CODE\n\nFor VS Code, Git integration is seamless, offering a version control sidebar\nthat lets developers stage, commit, and sync files.\n\nINTELLIJ IDEA\n\nJetBrains' IDEs, including IntelliJ IDEA and PyCharm are renowned for their\nversion control integrations. A dedicated 'Version Control' tool window provides\nan intuitive interface for Git operations.\n\nXCODE\n\nApple's Xcode has built-in support for Git-based repositories. Developers can\ninitiate version control directly from Xcode or link existing Git repositories\nto their projects.\n\nECLIPSE\n\nThe IDE can be set up with the EGit plugin to leverage Git functionalities\nseamlessly in an Eclipse environment.\n\n\nCODE EXAMPLE: VISUAL STUDIO CODE SETUP\n\nHere is the Bash code:\n\n# Check if Git is installed\ngit --version\n\n# If not installed, install Git from https://git-scm.com/\n# Verify installation\ngit --version\n\n# Open the folder to be tracked in VS Code\ncode path/to/your/folder\n\n# Initialize Git in the terminal\ngit init\n\n# Explicitly set up repository in VS Code\n# Or use 'Ctrl' + 'Shift' + 'G' to launch Git GUI in VS Code\n","index":90,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"92.\n\n\nDISCUSS THE PROS AND CONS OF USING A GUI TOOL FOR GIT VERSUS THE COMMAND LINE.","answer":"Let's look into the advantages of using a GUI tool versus the command line for\ntracking and managing code with Git.\n\n\nADVANTAGES OF GUI TOOLS\n\n * Visual Representation: The GUI provides a graphical view of your project\n   history, branches, merge points, and remote repositories. This can offer a\n   more intuitive understanding, especially for new users, or in complex\n   scenarios such as merge conflicts.\n * Reduced Cognitive Load: For users who are not comfortable with the command\n   line, a GUI can offer a lower barrier to entry. It can save time and effort\n   previously spent trying to recall or look up specific commands.\n * Efficiency in Complex Tasks: Actions like commit splitting or interactive\n   rebasing that may require meticulous command line usage are streamlined and\n   simplified in GUI tools. This can save time and reduce the risk of errors.\n\n\nDISADVANTAGES OF GUI TOOLS\n\n * Higher Resources Consumption: GUI tools typically consume more system\n   resources than command line operations. For machines with limited resources,\n   such as remote servers, command line can be more efficient.\n * Lack of Flexibility: GUIs may not expose certain advanced or\n   less-commonly-used Git functionalities, which can limit the user's ability to\n   fully leverage Git's capabilities.\n * Learning Limitations: Relying only on the GUI tool can lead to a limited\n   understanding of Git's underlying mechanics. This can potentially ring-fence\n   users to the tool's feature set and hinder adaptation to new tools or\n   workflows.\n\n\nPREFERRED USAGE SCENARIOS\n\n * Team Dynamics: A GUI might be a better fit for designers or less technical\n   team members needing to track changes without the overhead of a steep command\n   line learning curve.\n * Legacy Systems and Scripts: When dealing with legacy systems or\n   interdependent scripts, the command line is often a more robust and\n   consistent interface.\n * Git Novices: If users are not comfortable with the terminal, introducing a\n   GUI first can provide a smoother onboarding process, even if they might later\n   transition to the terminal for more advanced tasks.","index":91,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"93.\n\n\nWHAT PLUGINS ARE COMMONLY USED WITH GIT IN DEVELOPMENT ENVIRONMENTS?","answer":"Git is frequently bolstered by a range of plugins or integrated development\nenvironments (IDEs) for an optimized and efficient development experience. Here\nare some popular choices and their key features.\n\n\nCOMMONLY USED IDES AND PLUGINS FOR GIT\n\nVISUAL STUDIO CODE\n\n * Key Features: In-line diff, staging and commit assistance, conflict\n   resolution, and push/pull from any Git hosting service.\n * Extensions: GitLens, GitHub.\n\nINTELLIJ IDEA\n\n * Key Features: Unified VCS interface, in-line diff, automatic commits, and\n   branch management.\n * Tools: Git Integration, Gerrit.\n\nECLIPSE IDE\n\n * Key Features: GUI for Git actions, in-depth log viewer, and quick context\n   switching.\n * Tools: Git Staging, EGit.\n\nSUBLIME TEXT\n\n * Key Features: Blame annotations, in-line diff, and the ability to perform\n   most Git operations from the comfort of the editor.\n * Package: Sublime Merge.\n\nATOM\n\n * Key Features: In-line diff, interactive staging, and a unified interface to\n   manage Git operations.\n * Packages: Git-Plus, GitHub, git-diff-details.\n\nRUBYMINE\n\n * Key Features: Support for Git submodules, in-line diff, and automatic\n   conflict resolution.\n * Tools: Git Integration.\n\nXCODE\n\n * Key Features: Full-stack development on macOS and iOS, with built-in version\n   control via Git.\n * Integrated: Xcode Source Control.\n\n\nBENEFITS OF IDES AND GIT INTEGRATIONS\n\n * Consistency: Provides a uniform environment for Git operations irrespective\n   of the chosen IDE.\n * Visual Aids: In-line diffs and clear commit history enhance the understanding\n   of code changes.\n * Convenience: Eliminates the need to switch between the IDE and the\n   command-line for versioning tasks.","index":92,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"94.\n\n\nHOW DO YOU RESOLVE MERGE CONFLICTS USING A VISUAL TOOL?","answer":"When using a visual tool to resolve merge conflicts, you can opt for tools like\n\n * Visual Studio Code with its GitLens extension\n * IntelliJ IDEA\n * GitKraken.\n\nThese tools provide a user-friendly interface to tackle merge conflicts.\n\n\nVISUAL STUDIO CODE: GITLENS\n\nIf you are using Visual Studio Code, enable its GitLens extension to leverage\nvisual merge conflict resolution. After a conflict is detected, select the\nSource Control Icon in the Activity Bar.\n\nSTEPS\n\n 1. Click on the file displaying merge conflicts to open it.\n\n 2. GitLens provides the \"Accept Current Change\" and \"Accept Incoming Change\"\n    buttons alongside conflict markers.\n\n 3. Click on the relevant conflict markers or these buttons to resolve the\n    conflicts.\n\n 4. After resolving all conflicts in the file, stage or commit your changes\n    through the Source Control.\n\n\nINTELLIJ IDEA: GIT TOOL\n\nIn IntelliJ IDEA, the built-in Git tools enable visual resolution of merge\nconflicts. For each conflicting file, a dedicated merge manager is available.\n\nSTEPS\n\n 1. Navigate to the Files tool window and access the \"Log\" tab.\n\n 2. Locate and select the conflicted merge commit to bring up the \"Merge\" tab.\n\n 3. In this tab, you will see a list of conflicted files.\n\n 4. For each file, you can pick the changes from one of the branches or manually\n    edit the file to select specific changes.\n\n 5. Save and close the file to mark it as resolved.\n\n 6. After resolving all conflicts, proceed with a regular commit.\n\n\nGITKRAKEN: VISUAL TOOL\n\nGitKraken comes with an inbuilt merge conflict resolution tool. It visually\nrepresents both versions along with the common base to give you a comprehensive\nview of the conflicting changes.\n\nSTEPS\n\n 1. Import the repo into GitKraken and fetch the latest changes.\n\n 2. Locate the merge commit and click on the file that has conflicts.\n\n 3. GitKraken will present a three-pane editor displaying \"LOCAL\" changes on the\n    left, \"BASE\" in the center, and \"REMOTE\" on the right.\n\n 4. Use the graphical buttons to take either local or remote changes or drag\n    specific changes from one side to the other.\n\n 5. After completing the resolution task, commit your changes.","index":93,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"95.\n\n\nWHAT IS THE PURPOSE OF A GIT BRIDGE FOR VERSION CONTROL SYSTEMS?","answer":"Version Control Systems (VCS) like Git offer powerful functionality to manage\nproject versions, yet teams may need a VCS tool interoperability for efficient\ncollaboration. This is where a Git bridge becomes pivotal.\n\n\nWHY USE A GIT BRIDGE?\n\nA Git bridge serves several roles, including:\n\n * Backup and Sync: Teams can sync their repositories, offering an added layer\n   of backup. This is especially beneficial when repositories are on different\n   platforms, such as GitHub and Bitbucket, and is also useful for offline or\n   private projects.\n\n * Tool Integration: It enables the incorporation of code from other VCS into a\n   Git workflow, helping with cross-tool collaborations.\n\n * Assistance with Migration: If a team is considering switching from one VCS to\n   another, a Git bridge can provide a smooth transitional phase.\n\n\nCOMMON GIT BRIDGES\n\nSUBVERSION (SVN)\n\n * Purpose: Provides a Git interface to SVN repositories, allowing Git-like\n   workflows for SVN-based projects.\n\n * Functionality: Allows cloning of an SVN repository using Git, syncing changes\n   between SVN and Git, and maintaining a consistent history.\n\nMERCURIAL (HG-GIT)\n\n * Purpose: Establishes a two-way connection between Git and Mercurial\n   repositories, making it possible for Git users to contribute to Mercurial\n   projects and vice versa with a bi-directional bridge.\n\n * Functionality: Users can clone Mercurial repositories using Git and push\n   changes from the Git repository back to the Mercurial repository.\n\nPERFORCE (GIT FUSION)\n\n * Purpose: Integrates Helix Core (formerly Perforce) with Git, allowing\n   developers familiar with Git to access code in a Helix Core repository.\n\n * Functionality: Provides Git-like access to Helix Core repositories and\n   enables a two-way sync between the Helix Core and Git repositories.\n\nCLEARCASE (GIT-CC)\n\n * Purpose: Extends Git support for teams using IBM Rational ClearCase, helping\n   users familiar with Git to work with ClearCase repositories using Git\n   commands.\n\n * Functionality: Offers basic Git commands like clone, fetch, and pull for\n   ClearCase repositories.\n\n\nCODE EXAMPLE: CLONING AN SVN REPOSITORY WITH GIT\n\nHere is the code:\n\n# Clone a repository using the 'git svn clone' command\ngit svn clone <SVN_URL> <LOCAL_DIRECTORY>\n","index":94,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"96.\n\n\nHOW DO YOU HANDLE LARGE BINARY FILES IN GIT WITHOUT USING GIT LFS?","answer":"While Git LFS is a popular choice for managing large binary files in Git,\nalternate strategies can be employed without relying on a dedicated extension.\n\n\nTECHNIQUES FOR HANDLING LARGE BINARY FILES\n\n 1. cURL: This method entails storing the large binary files on a separate\n    server and using curl to download them during the checkout process. To\n    automate this, use Git hooks, such as post-checkout.\n\n 2. SSH or SSL: This approach involves instructing developers to use keys for\n    authentication or SSL certification when working with large files.\n\n 3. External Package Managers: When feasible, utilize third-party package\n    managers. Tools like Maven for Java and CocoaPods for iOS can manage\n    dependencies.\n\n 4. Submodules: While not designed specifically for managing large files,\n    submodules can be configured to point to repositories holding such assets.\n\n 5. Archives: Another option is to employ file archives, such as ZIP or 7z, for\n    large artifacts. However, this method is not conducive to version control.\n\n 6. Custom Scripts: Tailored scripts can be devised to automate the process of\n    retrieving and managing large files when cloning or checking out\n    repositories.\n\n\nBEST PRACTICES WHEN MANAGING LARGE FILES\n\n 1. Version the Scripts: If employing custom scripts or configuration files for\n    automated handling, ensure these are versioned.\n\n 2. Communication: Inform developers of the large files management strategy and\n    any necessary action steps they are required to follow.\n\n 3. Optimization: Aim to strike a balance between maintaining an efficient\n    repository and preserving versioned binary files.\n\n 4. Pruning and Garbage Collection: Implement regular cleanup processes to\n    eliminate outdated or unnecessary files.\n\n 5. Repository Size: Monitor the repository size and keep it in check to ensure\n    responsiveness and optimize storage costs.\n\n 6. Backups: Ensure robust backup mechanisms are in place, especially when\n    storing large files on external servers or environments.","index":95,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"97.\n\n\nWHAT IS THE PURPOSE OF THE GIT REBASE -I COMMAND?","answer":"Interactive Rebase, activated via git rebase -i, empowers developers to curate\nand streamline commit history. It provides a visual prompt enabling them to\nreorder, squash, edit, and more.\n\n\nWHY USE INTERACTIVE REBASE?\n\n * Leverages Commit Precision: Git is known for its fine-grained commits.\n   Interactive Rebase capitalizes on this, allowing developers to craft a\n   polished commit history.\n\n * Primes for Public Interaction: Transforms local, raw commits into a refined\n   state before sharing with collaborators.\n\n * Simplifies Code Review: By presenting comprehensible, focused changes, it\n   makes the code review process more efficient.\n\n * Improves Version Clarity: By removing or combining insignificant or\n   error-prone commits, rebase helps maintain versions that are easy to track\n   and understand.\n\n\nMULTI-STEP PROCESS\n\nAn Interactive Rebase comprises three distinct phases:\n\n1. SETTING THE RECOVERY POINT\n\nBefore launching into a rebase, the user specifies a \"recovery point\", which is\ntypically the commit preceding the oldest commit to be rebased.\n\n# Example: Move to a commit before the range to be rebased, e.g. previous to commit \"featX\"\ngit rebase -i HEAD~4\n\n\n2. THE MENU SYSTEM\n\nGit initiates a text-based rebase \"menu\", presenting various commands\ncorresponding to commit manipulation actions. From reordering to squashing or\nsplitting, each command is linked to a specific keyboard shortcut.\n\nA standard multi-commit interactive rebase menu might look like this:\n\npick 192b13d Commit A\nsquash 23044ce Commit B\nedit 10308c4 Commit C\npick 75826d3 Commit D\n\n\n3. EXECUTING COMMANDS\n\nPost menu configuration, Git seamlessly performs the sequence of actions,\naltering the commit history as programmed in the menu.\n\n\nSTEROIDS FOR PRODUCTIVITY\n\nInteractive Rebase offers several productivity-boosting actions via intuitive\nkeyboard shortcuts.\n\nCOMMON SHORTCUTS\n\n * dd: Drop a commit (remove it entirely).\n * s: Squash a commit into the one above.\n * f: Use the previous commit message, optionally merging with the current.\n\nADDITIONAL SHORTCUTS\n\n * r: Reword a commit—similar to \"edit\" but focused on changing commit messages.\n * e: Edit a commit. Git will pause at each edited commit, allowing changes\n   before proceeding.\n   * This feature gives developers the chance to break a large change into\n     smaller, logically separated ones.\n\n\nRISKS AND BEST PRACTICES\n\n * Avoid Editing Public Commits: This could lead to inconsistencies among\n   collaborators.\n * Timeline Integrity: Only reorder commits if they logically make sense in a\n   different order.\n * Mind the Merge: Avoid rebasing shared branches with merges to prevent future\n   integration difficulties.","index":96,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"98.\n\n\nHOW WOULD YOU SET UP A CONTINUOUS BACKUP PROCESS FOR GIT REPOSITORIES?","answer":"For ensuring Git repository backup, you can adopt a combination of distributed\nand centralized backup systems.\n\n\nWHAT IS A DISTRIBUTED BACKUP?\n\nWhere possible, aim to distribute repository backups across multiple hosts. For\nexample, on GitHub, every repository can be a backup for other local ones.\n\nDistributed models provide redundancy and fault-tolerance since data is copied\nto multiple locations.\n\n\nHOW GIT ALONE SUPPORTS EFFECTIVE DISTRIBUTED BACKUP\n\nAll local clones serve as backups for the primary repository. Regularly fetching\nupdates from the primary and pushing your local changes can ensure up-to-date\nbackups.\n\nWhen collaborating via a shared central repository:\n\n * If the central repository is lost, it can be restored from any of the\n   collaborators' forks or clones.\n * Popular platforms like GitHub ensure high-availability and continuous\n   backups.\n\nIn a team setting, each team member can have their own local clone, providing\nfault-tolerance at the individual level.\n\n\nCENTRALIZED BACKUP\n\nIn addition to distributed backup mechanisms, a centralized backup approach can\nbe beneficial for:\n\n * Completing the backup picture, especially in decentralized environments.\n * Simplifying backup and restoration processes.\n\nSeveral tools can automate the backing up of Git repositories to a central\nserver. One of the most popular choices is using Git hooks.\n\n\nUSING GIT HOOKS FOR AUTOMATED BACKUPS\n\nTYPES OF GIT HOOKS\n\n * Post-Receive: Executes commands upon successful receiving of git commits.\n   Often used to trigger backup mechanisms.\n * Pre-Receive: Executes commands before receiving commits. Useful for enforcing\n   custom policies or performing validation.\n * Post-Update: A more advanced hook, focusing on branches 'update' after a\n   receive or update.\n\nSETTING UP POST-RECEIVE HOOKS LOCALLY\n\nLocally, navigate to the .git directory in your repository and find the hooks\nsubdirectory. You can place an executable script in the post-receive file. This\nscript can, for instance, push changes to a designated backup location.\n\nEXAMPLE OF POST-RECEIVE HOOK\n\nHere is the Shell Script:\n\n#!/bin/bash\necho \"Pushing to Backup\"\ngit push backup-repo\n\n\nAfter setting up the hook, pushing to the repository would trigger this script\nto run, thus initiating a backup to the \"backup-repo\" remote.\n\n\nADDITIONAL STRATEGIES TO STRENGTHEN DATA SECURITY\n\n * Secure Shell (SSH): Emphasize secure, encrypted communication for data\n   transfers.\n * Access Management: Limit access rights to ensure backup repositories remain\n   unchanged except through automated processes.\n   Optimize backup strategies for specific use cases, balancing redundancy,\n   security, and operational efficiency.","index":97,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"99.\n\n\nEXPLAIN THE IMPACT OF CASE SENSITIVITY IN GIT AND HOW TO MANAGE IT ACROSS\nDIFFERENT OPERATING SYSTEMS.","answer":"Case sensitivity plays a role in how operating systems like Windows, macOS, and\nLinux handle file names. This can lead to challenges in cross-platform\ndevelopment.\n\n\nCASE SENSITIVITY: A CROSS-PLATFORM CHALLENGE\n\n * Windows: Typically, not case-sensitive. It treats file.txt, File.txt, and\n   FILE.TXT as the same file in the same directory.\n\n * Unix/Linux and macOS: Case-sensitive. These systems see file.txt, File.txt,\n   and FILE.TXT as three distinct files in a directory.\n\n\nGIT & ECOSYSTEMS: THE CASE-SENSITIVITY DIFFERENTIAL\n\nECOSYSTEMS\n\n * Windows: Relatively insensitive to case, albeit Git for Windows has optional\n   case-sensitivity.\n\n * Unix/Linux and macOS: Sensitive to case.\n\nGIT'S ROLE\n\n * Core Storage: Git's internal system is case-sensitive.\n\n\nCROSS-PLATFORM SOLUTIONS\n\nADJUSTING LOCAL CONFIGURATIONS\n\nIn case of system-specific variations, adjust Git configurations.\n\n * Setting core.ignorecase: For Windows, set it to true; for Unix/Linux and\n   macOS systems, keep it as false.\n\nMITIGATING IN VISUAL STUDIO CODE\n\nBetween the editor and the git system, VS Code provides an additional layer of\ncontrol:\n\n * Disk and Editor: It can be set to ignore case changes.\n\nCODE EXAMPLE: SETTING CORE.IGNORECASE\n\nFor Windows:\n\ngit config core.ignorecase true\n\n\nFor Unix:\n\ngit config core.ignorecase false\n\n\n\nBASH TOOLS TO HELP WITH CASE SENSITIVITY\n\n * rm and .gitignore: Use git rm to remove cached files and update .gitignore to\n   work with untracked files.\n   \n   * Windows: git rm --cached -r SomeDirectory/\n   * Unix: git rm -r SomeDirectory/\n\n * Finding Duplicates: Use ls | uniq -d on Unix to uncover case conflicts.\n\n\nVERSATILE SOLUTIONS\n\nTools & languages often used in cross-platform development offer ways to help\nbridge the case-sensitivity gap:\n\n * Visual Studio Code: Integrates case-insensitivity between the operating\n   systems.\n * Java, .NET, and Node.js: File-handling APIs can be customized to cater for\n   case-variations. This can be valuable when bringing a project on board; it'd\n   make sense to code with case-sensitivity locally intact, as that's the\n   typical application.","index":98,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"},{"text":"100.\n\n\nHOW DO YOU MAINTAIN MULTIPLE VERSIONS OF A PRODUCT USING GIT BRANCHES FOR EACH\nVERSION?","answer":"Branching in Git allows for efficient version control and multiple development\nlines. When managing different versions\ne.g.,production,staging,anddevelopmente.g., production, staging, and\ndevelopmente.g.,production,staging,anddevelopment, each environment can have its\nown dedicated branch.\n\n\nKEY BRANCHING STRATEGIES\n\n 1. Long-Lived Branches: Remain consistent over time.\n 2. Topic Branches: Short-lived, dedicated to specific features.\n 3. Release Branches: Prepare for a new version's release.\n\n\nVERSION CONTROL MODELS\n\nRELEASE PROCESS MODEL\n\n 1. Development: Ongoing changes for the next release\n    e.g.,onthe‘main‘branche.g., on the `main` branche.g.,onthe‘main‘branch.\n 2. Staging: Testing and final preparations for release\n    e.g.,ona‘staging‘branche.g., on a `staging` branche.g.,ona‘staging‘branch.\n 3. Production: Represents the latest released version\n    e.g.,onthe‘production‘branche.g., on the `production`\n    branche.g.,onthe‘production‘branch.\n\nGIT-FLOW MODEL\n\n 1. Development: Ongoing development e.g.,onthe‘develop‘branche.g., on the\n    `develop` branche.g.,onthe‘develop‘branch.\n 2. Feature: Independent features get developed e.g.,‘feature/my−feature‘e.g.,\n    `feature/my-feature`e.g.,‘feature/my−feature‘.\n 3. Release: Preparations for the next release e.g.,‘release/x.x.x‘e.g.,\n    `release/x.x.x`e.g.,‘release/x.x.x‘.\n 4. Hotfix: Quick fixes on the production release e.g.,‘hotfix/my−hotfix‘e.g.,\n    `hotfix/my-hotfix`e.g.,‘hotfix/my−hotfix‘.\n 5. Support: Maintenance of older releases\n    e.g.,‘support/x.x.x‘forolderreleasese.g., `support/x.x.x` for older\n    releasese.g.,‘support/x.x.x‘forolderreleases.\n\nChoose a model that best aligns with project requirements. Keep in mind that\nwhile these models offer structure and organization, it's essential to adapt\nprocesses according to project specifics and team dynamics.","index":99,"topic":" GIT ","category":"Web & Mobile Dev Fullstack Dev"}]
